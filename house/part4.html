<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Blog about declarative home automation, smart home systems, and avoiding vendor lock-in with Nix-based solutions">
    <meta property="og:title" content="Declarative Home Automation with Nix">
    <meta property="og:description" content="Learn how to define your smart home devices and avoid vendor lock-in">
    <meta property="og:type" content="article">
    <meta name="twitter:card" content="summary_large_image">
    <title>ü¶Üüßë‚Äçü¶Ø'blog</title>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>

    <div class="navbar">
        <div class="navbar-content">
            <a href="https://github.com/QuackHack-McBlindy" title="GitHub">
                <img src="../img/github_teal.png" alt="GitHub" class="github-icon" style="height: 32px;" onmouseover="this.src='../img/github_magenta.png';" onmouseout="this.src='../img/github_teal.png';"> </img>
            </a>
            
            <div class="navbar-title">
                <span>ü¶Ü</span>üßë‚Äçü¶Ø <a href="https://quackhack-mcblindy.github.io/blog/">QuackHack-McBlindy blog</a>
            </div>
            <img src="../img/logo.png" height="48" width="48" >
            <button id="duckToggle" class="toggle-btn" aria-label="Toggle duck commentary">

                <span class="duck-icon">ü¶Ü</span>
                Hide duck commentary
            </button>
        </div>
    </div>
    

    <div class="toc-container">
        <details class="toc-details">
            <summary class="toc-header">
                <span class="toc-duck">ü¶Ü</span>
                <h3>Navigation</h3>
                <span class="toc-man">üßë‚Äçü¶Ø</span>
                <span class="toc-toggle">‚Æü</span>
            </summary>
            <nav class="toc-nav">
                <a href="../yo/index.html" class="toc-item">
                    <span class="toc-icon">ü´Ä</span>
                    Yo - Define & Unify
                </a>
                <a href="../do/index.html" class="toc-item">
                    <span class="toc-icon">üß†</span>
                    Do - Listen, Process, Act & Learn
                </a>
                <a href="index.html" class="toc-item current">
                    <span class="toc-icon">üè†</span>
                    House - Declarative Home Automation
                    <span class="current-marker">‚Æúü¶Ü</span>
                </a>
                <a href="../docs/index.html" class="toc-item">
                    <span class="toc-icon">üìö</span>
                    Documentation - Automating the README
                </a>
                <a href="../misc/index.html" class="toc-item">
                    <span class="toc-icon">üß©</span>
                    Miscellaneous 
                </a>
            </nav>
            <div class="toc-footer">
                <span class="toc-quack">ü¶Ü says ‚Æû qwack qwack, plx pick!</span>
            </div>
        </details>
    </div>
    
  
    <div class="content">
        <header class="category-title">
            <h1>Defining Your Home</h1>
            <p class="subtitle"> Part 4 - Writing a Server Service</p>
        </header>

        
        <div class="duck-comment">
            <p>says ‚Æû I use 20x magnification when I code and debug. I use emoji to simplify logs for myself. If you can't handle my code style you can disable most of it on this website by toggling the button in the navbar. Shall duck continue? </p>
        </div>


  
        <p>
            Originally written in Bash, but sadly once again I overestimated what heavylifting Bash could handle.<br>
            It's now in RUst and I am very happy with the performance.<br>
            I will very briefly explain how it works and show some example code. <i>(Please note that the code blocks on this page are just example snippets)</i>
            <br><br>
            
            The Rust code is written in a Nix string and is generated upom build time.<br>
            Defined devices, automations and other configurations are inserted into variables as json files and loaded into the runtime.
            
            <br><br>
            
            You will have the link to the source code on GitHub at the bottom of this page.<br>
            There's basically nothing in the code that needs to be changed if you would like to try it.<br>            
            <br>
            If you want to run the service without 'yo' you would simply build it in the zigduck-rs systemd service's preStart definition.<br>
            
        </p>


        <h2 class="section-title">File Structure</h2>
        <p>Pretty straightforward structure, that's easy to follow.<br>
        </p>


        <details class="code-block-container" style="margin-bottom: 1em;">
          <summary class="code-header">
              <div class="code-lang">‚Æû View Nix File Structure</div>
          </summary>
              <div class="code-block">
                <pre><span class="duck-version">
  # ü¶Ü says ‚Æû Generate automations configuration
  automationsJSON = builtins.toJSON config.house.zigbee.automations;
  automationsFile = pkgs.writeText "automations.json" automationsJSON;

  # ü¶Ü says ‚Æû Dark time enabled flag
  darkTimeEnabled = if config.house.zigbee.darkTime.enable then "1" else "0";

  # ü¶Ü needz 4 rust  
  devices-json = pkgs.writeText "devices.json" deviceMeta;
  # ü¶Ü says ‚Æû RUSTY SMART HOME qwack qwack     
  zigduck-rs = pkgs.writeText "zigduck-rs" ''        
    use rumqttc::{MqttOptions, Client, QoS, Event, Incoming};
    #ü¶Ü...
  '';

  # ü¶Ü says ‚Æû Cargo.toml
  zigduck-toml = pkgs.writeText "zigduck.toml" ''    
    [package]
    name = "zigduck-rs"
    #ü¶Ü...
  '';
  environment.variables."ZIGBEE_DEVICES" = deviceMeta;
  environment.variables."ZIGBEE_DEVICES_FILE" = devices-json;
  environment.variables."AUTOMATIONS_FILE" = automationsFile;

in {
  systemd.services.zigduck-rs = {
    serviceConfig = {
      User = "zigduck";
      Group = "zigduck";
      Exec = "./target/release/zigduck-rs";
      StateDirectory = "zigduck";
      StateDirectoryMode = "0755";
    };
    preStart = ''
      if [ ! -f "${zigduckDir}/state.json" ]; then
        echo "{}" > "${zigduckDir}/state.json"
      fi   
      
      mkdir -p "${zigduckDir}/timers"
      mkdir -p src
      # ü¶Ü says ‚Æû create the source filez yo 
      cat ${zigduck-rs} > src/main.rs
      cat ${zigduck-toml} > Cargo.toml
      
      # ü¶Ü says ‚Æû build
      ${pkgs.cargo}/bin/cargo generate-lockfile      
      ${pkgs.cargo}/bin/cargo build --release   
    '';
  };

  systemd.tmpfiles.rules = [
    "d /var/lib/zigduck 0755 ${config.this.user.me.name} ${config.this.user.me.name} - -"
    "d /var/lib/zigduck/timers 0755 ${config.this.user.me.name} ${config.this.user.me.name} - -"
    "f /var/lib/zigduck/state.json 0644 ${config.this.user.me.name} ${config.this.user.me.name} - -"
  ];
</span><span class="clean-version hidden">
  automationsJSON = builtins.toJSON config.house.zigbee.automations;
  automationsFile = pkgs.writeText "automations.json" automationsJSON;

  darkTimeEnabled = if config.house.zigbee.darkTime.enable then "1" else "0";

  devices-json = pkgs.writeText "devices.json" deviceMeta;

  zigduck-rs = pkgs.writeText "zigduck-rs" ''        
    use rumqttc::{MqttOptions, Client, QoS, Event, Incoming};
    # ...
  '';

  zigduck-toml = pkgs.writeText "zigduck.toml" ''    
    [package]
    name = "zigduck-rs"
    # ...
  '';
  environment.variables."ZIGBEE_DEVICES" = deviceMeta;
  environment.variables."ZIGBEE_DEVICES_FILE" = devices-json;
  environment.variables."AUTOMATIONS_FILE" = automationsFile;

in {
  systemd.services.zigduck-rs = {
    serviceConfig = {
      User = "zigduck";
      Group = "zigduck";
      Exec = "./target/release/zigduck-rs";
      StateDirectory = "zigduck";
      StateDirectoryMode = "0755";
    };
    preStart = ''
      if [ ! -f "${zigduckDir}/state.json" ]; then
        echo "{}" > "${zigduckDir}/state.json"
      fi   
      
      mkdir -p "${zigduckDir}/timers"
      mkdir -p src

      cat ${zigduck-rs} > src/main.rs
      cat ${zigduck-toml} > Cargo.toml
      
      ${pkgs.cargo}/bin/cargo generate-lockfile      
      ${pkgs.cargo}/bin/cargo build --release   
    '';
  };

  systemd.tmpfiles.rules = [
    "d /var/lib/zigduck 0755 ${config.this.user.me.name} ${config.this.user.me.name} - -"
    "d /var/lib/zigduck/timers 0755 ${config.this.user.me.name} ${config.this.user.me.name} - -"
    "f /var/lib/zigduck/state.json 0644 ${config.this.user.me.name} ${config.this.user.me.name} - -"
  ];
</span></pre>
            </div>
        </div>
    </details>        





        <h2 class="section-title">Main Event Loop</h2>

        <p>
           The main loop that maintains persistent Mosquitto connection, listens for all Zigbee device messages, and automatically recovers from connection failures.
        </p><br>

        <details class="code-block-container" style="margin-bottom: 1em;">
          <summary class="code-header">
              <div class="code-lang">‚Æû View Main Event Loop Summary</div>
          </summary>
              <div class="code-block">
                <pre><span class="duck-version">
// ü¶Ü says ‚Æû i dont alwayz qwack i can listenz
async fn start_listening(&mut self) -> Result<(), Box<dyn std::error::Error>> {
    let (mut client, mut connection) = Client::new(mqttoptions, 10);
    client.subscribe("zigbee2mqtt/#", QoS::AtMostOnce)?;
    
    loop {
        match connection.eventloop.poll().await {
            Ok(event) => {
                if let Event::Incoming(Incoming::Publish(publish)) = event {
                    let topic = publish.topic;
                    let payload = String::from_utf8_lossy(&publish.payload);
                    self.process_message(&topic, &payload).await?;
                }
            }
            Err(e) => {
                // ü¶Ü says ‚Æû auto reconnect ..
                tokio::time::sleep(Duration::from_secs(5)).await;
                // ü¶Ü says ‚Æû recreate connection & resubscribe
            }
        }
    }
}
</span><span class="clean-version hidden">
async fn start_listening(&mut self) -> Result<(), Box<dyn std::error::Error>> {
    let (mut client, mut connection) = Client::new(mqttoptions, 10);
    client.subscribe("zigbee2mqtt/#", QoS::AtMostOnce)?;
    
    loop {
        match connection.eventloop.poll().await {
            Ok(event) => {
                if let Event::Incoming(Incoming::Publish(publish)) = event {
                    let topic = publish.topic;
                    let payload = String::from_utf8_lossy(&publish.payload);
                    self.process_message(&topic, &payload).await?;
                }
            }
            Err(e) => {
                // Auto reconnect ...
                tokio::time::sleep(Duration::from_secs(5)).await;
                // Recreate connection & resubscribe
            }
        }
    }
}
</span></pre>
            </div>
        </div>
    </details>        


            <div class="duck-comment">
                <p>
                    says ‚Æû datz good if ur zigstick is bad qwack!1 
                </p>
            </div>            



            <h2 class="section-title">Message Processing & Device State Management</h2>
            <p>Parsing incoming Mosquitto messages and extracts device data.<br>
            Maintains it's own state file of all devices, and routes messages to correct handlers based on device type.<br>
            <br>

            </p>


        <details class="code-block-container" style="margin-bottom: 1em;">
          <summary class="code-header">
              <div class="code-lang">‚Æû View Message Processing Handler</div>
          </summary>
              <div class="code-block">
                <pre><span class="duck-version">
// ü¶Ü says ‚Æû letzz do diz! 
async fn process_message(&mut self, topic: &str, payload: &str) -> Result<(), Box<dyn std::error::Error>> {
    let data: Value = serde_json::from_str(payload)?;
    let device_name = topic.strip_prefix("zigbee2mqtt/").unwrap_or(topic);
    
    // ü¶Ü says ‚Æû update device statez from all dem fields
    self.update_device_state_from_data(device_name, &data)?;
    
    if let Some(device) = self.devices.get(device_name) {
        let room = &device.room;
        // ü¶Ü says ‚Æû handle all dem sensor typez triggerz!
        match device.device_type.as_str() {
            "motion" => {     //ü¶Üsays‚ÆûMOTION SENSORS }
            "contact" => {    //ü¶Üsays‚ÆûDOOR/WINDOW SENSORS }
            "water_leak" => { //ü¶Üsays‚ÆûWATER LEAK SENSORS }
            // ü¶Üsays‚Æû MORE? qwack qwack
        }
    }
}
</span><span class="clean-version hidden">
async fn process_message(&mut self, topic: &str, payload: &str) -> Result<(), Box<dyn std::error::Error>> {
    let data: Value = serde_json::from_str(payload)?;
    let device_name = topic.strip_prefix("zigbee2mqtt/").unwrap_or(topic);
    
    self.update_device_state_from_data(device_name, &data)?;
    
    if let Some(device) = self.devices.get(device_name) {
        let room = &device.room;
        match device.device_type.as_str() {
            "motion" => { ... }
            "contact" => { ... }
            "water_leak" => { ... }
            // ...
        }
    }
}
</span></pre>
            </div>
        </div>
    </details>        



            <h2 class="section-title">Smart Dimmer Handling</h2>
            <p>Smart dimmer handling that supports configurable behaviors per room.<br>
            Default actions already programmed in the Rust code.<br>
            Which means it works as you would expect out of the box.<br>
            <br><br>
            As shown in part 3 - it is equipped to handle pretty complex automations.<br>
            The way it works is that it loads room specific dimmer configurations,<br>
            and executes defined override actions or default + defined extra actions.<br>
            </p>


        <details class="code-block-container" style="margin-bottom: 1em;">
          <summary class="code-header">
              <div class="code-lang">‚Æû View Dimmer Switch Action Handler</div>
          </summary>
              <div class="code-block">
                <pre><span class="duck-version">
// ü¶Ü says ‚Æû letz go yo!
fn handle_room_dimmer_action<F>(
    &self, 
    action: &str, 
    device_name: &str, 
    room: &str,
    default_action: F
) -> Result<(), Box<dyn std::error::Error>> 
{
    // ü¶Ü says ‚Æûany room configurationz?
    if let Some(room_actions) = self.automations.dimmer_actions.get(room) {
        let dimmer_action = match action {
            "on_press_release" => &room_actions.on_press_release,
            "on_hold_release" => &room_actions.on_hold_release,
            // ... ü¶Ü says ‚Æû da rest actionz
        };
        
        // ü¶Ü says ‚Æûexecute override actionz or default + extra actionz
        if !config.override_actions.is_empty() {
            for override_action in &config.override_actions {
                self.execute_automation_action(override_action, device_name, room)?;
            }
        } else {
            default_action(room)?;  // ü¶Üsays‚Æûrun da defaultz
            for extra_action in &config.extra_actions {
                self.execute_automation_action(extra_action, device_name, room)?;
            }
        }
    }
}
</span><span class="clean-version hidden">
fn handle_room_dimmer_action<F>(
    &self, 
    action: &str, 
    device_name: &str, 
    room: &str,
    default_action: F
) -> Result<(), Box<dyn std::error::Error>> 
{
    if let Some(room_actions) = self.automations.dimmer_actions.get(room) {
        let dimmer_action = match action {
            "on_press_release" => &room_actions.on_press_release,
            "on_hold_release" => &room_actions.on_hold_release,
            // ...
        };
        
        if !config.override_actions.is_empty() {
            for override_action in &config.override_actions {
                self.execute_automation_action(override_action, device_name, room)?;
            }
        } else {
            default_action(room)?;
            for extra_action in &config.extra_actions {
                self.execute_automation_action(extra_action, device_name, room)?;
            }
        }
    }
}
</span></pre>
            </div>
        </div>
    </details>        






            <h2 class="section-title">Automations & Conditions</h2>
            <p>
            </p>


        <details class="code-block-container" style="margin-bottom: 1em;">
          <summary class="code-header">
              <div class="code-lang">‚Æû View COnditions Code Snippet</div>
          </summary>
              <div class="code-block">
                <pre><span class="duck-version">
async fn check_conditions(&self, conditions: &[Condition]) -> bool {
    for condition in conditions {
        if !self.check_condition(condition).await {
            return false;
        }
    }
    true
}

async fn check_condition(&self, condition: &Condition) -> bool {
    match condition.condition_type.as_str() {
        "dark_time" => self.is_dark_time(),
        "someone_home" => self.is_someone_home(),
        "room_occupied" => {
            if let Some(room) = &condition.room {
                self.is_motion_triggered(room) || self.has_recent_motion_in_room(room)
            } else { false }
        }
        _ => false,
    }
}
</span><span class="clean-version hidden">
async fn check_conditions(&self, conditions: &[Condition]) -> bool {
    for condition in conditions {
        if !self.check_condition(condition).await {
            return false;
        }
    }
    true
}

async fn check_condition(&self, condition: &Condition) -> bool {
    match condition.condition_type.as_str() {
        "dark_time" => self.is_dark_time(),
        "someone_home" => self.is_someone_home(),
        "room_occupied" => {
            if let Some(room) = &condition.room {
                self.is_motion_triggered(room) || self.has_recent_motion_in_room(room)
            } else { false }
        }
        _ => false,
    }
}
</span></pre>
            </div>
        </div>
    </details>        








            <h2 class="section-title">The Full Source</h2>
    
            <a href="https://github.com/QuackHack-McBlindy/dotfiles/blob/main/bin/home/zigduck-rs.nix" class="source-link">
              View source code on GitHub
            </a><br>   



            <h2 class="section-title">Keep Reading</h2>
        
            <a href ="part1.html">Part 1. The module, the options and defining devices</a><br>
            <a href ="part2.html">Part 2. Configure your Mosquitto/Z2MQTT</a><br>
            <a href ="part3.html">Part 3. Nix Configured Automations</a> <br>           
            <a href ="part4.html">Part 4. Writing a Server Service - in Rust</a><span class="current-marker">‚Æúü¶Ühere u are</span><br>     
            <a href ="part5.html">Part 5. Writing a Client - With Voice Commands</a>   <br>   
            <a href ="part6.html">Part 6. The Auto-Generated Dashboard</a><br>        

            <br><br>
    

            <section id="comments">
              <h2>Comments on this blog post</h2>
              <script 
                src="https://utteranc.es/client.js"
                repo="QuackHack-McBlindy/blog"
                issue-term="pathname"
                theme="github-light"
                crossorigin="anonymous"
                async>
              </script>
            </section>
        </p>
    </div>



    </div>
    
    <footer>
        <p>All thoughts are my own and should not be considered advice of any kind. More likely the opposite.</p>
    </footer>

    <script src="../js/script.js"></script>
</body>
</html>
