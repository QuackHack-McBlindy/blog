<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="h0N8wN3LfuoAR-RnBsQbPLp23Eev2TIy5VVBfgFXiyc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NixOS dotfiles Tips & Guides | QuackHack-McBlindy's Blog</title>
    <meta name="description" content="It‚Äôs not ‚Äújust dotfiles‚Äù - it's extreme modularity that looks and feels like a NixOS flake. It's Voice-driven DevOps, it's a declarative home automation system, it's a self-contained auto-documenting monster.">
    
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://quackhack-mcblindy.github.io/blog/">
    <meta property="og:title" content="NixOS dotfiles Tips & Guides | QuackHack-McBlindy's Blog">
    <meta property="og:description" content="It‚Äôs not ‚Äújust dotfiles‚Äù - it's extreme modularity that looks and feels like a NixOS flake. It's Voice-driven DevOps, it's a declarative home automation system, it's a self-contained auto-documenting monster.">
    <meta property="og:image" content="https://quackhack-mcblindy.github.io/blog/img/logo.png">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="NixOS & dotfiles: My Declarative Smart Home">
    <meta name="twitter:description" content="Beyond dotfiles: A modular, voice-driven DevOps and home automation system built with NixOS.">
    <meta name="twitter:image" content="https://quackhack-mcblindy.github.io/blog/img/logo.png">
    
    <link rel="canonical" href="https://quackhack-mcblindy.github.io/blog/" />
    <link rel="stylesheet" href="./../css/styles.css">
    <link rel="stylesheet" href="./../css/styles5.css">



</head>
<body>

    <div class="navbar">
        <div class="navbar-content">
            <a href="https://github.com/QuackHack-McBlindy" title="GitHub">
                <img src="../img/github_teal.png" alt="GitHub" class="github-icon" style="height: 32px;" onmouseover="this.src='../img/github_magenta.png';" onmouseout="this.src='../img/github_teal.png';"> </img>
            </a>
            <img src="../img/logo.png" height="48" width="48" >
            <div class="navbar-title">
                <span>ü¶Ü</span>üßë‚Äçü¶Ø <a href="https://quackhack-mcblindy.github.io/blog/">QuackHack-McBlindy blog</a>
            </div>
            <button id="duckToggle" class="toggle-btn">
                <span class="duck-icon">ü¶Ü</span>
                Hide duck commentary
            </button>
        </div>
    </div>
    

    <div class="toc-container">
        <details class="toc-details">
            <summary class="toc-header">
                <span class="toc-duck">ü¶Ü</span>
                <h3>Navigation</h3>
                <span class="toc-man">üßë‚Äçü¶Ø</span>
                <span class="toc-toggle">‚ñº</span>
            </summary>
            <nav class="toc-nav">
                <a href="../yo/index.html" class="toc-item">
                    <span class="toc-icon">ü´Ä</span>
                    Yo - Define & Unify
                </a>
                <a href="../do/index.html" class="toc-item">
                    <span class="toc-icon">üß†</span>
                    Do - Listen, Process, Act & Learn
                </a>
                <a href="index.html" class="toc-item current">
                    <span class="toc-icon">üè†</span>
                    House - Declarative Home Automation
                    <span class="current-marker">‚óÄü¶Ü</span>
                </a>
                <a href="../docs/index.html" class="toc-item">
                    <span class="toc-icon">üìö</span>
                    Documentation - Automating the README
                </a>
                <a href="../misc/index.html" class="toc-item">
                    <span class="toc-icon">üß©</span>
                    Miscellaneous
                </a>
            </nav>
            <div class="toc-footer">
                <span class="toc-quack">ü¶Ü says ‚ñ∂ qwack qwack, plx pick!</span>
            </div>
        </details>
    </div>
    
  
    <div class="content">
        <header class="category-title">
            <h1>Defining Your Home</h1>
            <p class="subtitle">Part 7 - Let's Build a ChatBot!<br></p>
        </header>

        
        <div class="duck-comment">
            <p>‚ñ∂ I use 20x magnification when I code and debug. I use emoji to simplify logs for myself. If you can't handle my code style you can disable most of it on this website by toggling the button in the navbar. Shall duck continue? </p>
        </div>
        
        <p>
            Today we'll add another page to our dashboard. <br>
            We will dive deeper into JS and at first glance it will look more advanced and a bit messy - but it will be well worth the time, because we will implement a chat interface.<br>
            Let's build a bridge between our natural language processor <i>(do)</i> and our frontend dashboard.<br>
            
        </p>


     
        <h2 class="section-title">Why?</h2>
        
        <p>
            I wanted to build something that not only gives full access to all my <i>(yo)</i> scripts while on the run, but also gave appropriate responses, rendered beautifully right in the chat. Text to speech is of course crucial here as well. At first I was struggling to get a good voice for TTS - I needed it to sound just as good on desktop as on mobile, which seemed really hard to achieve since to my surprise I realized Apple has yet to release Siri on any open API. I ended up using what I already use on desktop, Piper and just create the wav server-side and playing the audio client-side.<br><br> My original thought for the chat was to build something that felt like ChatGPT - but faster, more reliable and without the thinking process. In simple terms:<br>
            <strong>Less thinking - more doing!</strong> <br><br>
            But before we start - I'll throw you a <strong>video teaser</strong> so you know what's what! <i>(turn on your sound)</i>
        </p><br>

        <h2 class="section-title">Ask What Time It Is</h2><br>
        
        <video width="400" controls>
            <source src="https://raw.githubusercontent.com/QuackHack-McBlindy/blog/main/img/time_cmd.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video> <br><br>

        <h2 class="section-title">Understands 294 Million Phrases - This Is Not One Of Them</h2><br> 

        <video width="400" controls>
            <source src="https://raw.githubusercontent.com/QuackHack-McBlindy/blog/main/img/failed_cmd.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video><br><br>
        
        <p>
            Shall we start?
        </p> 
  
        <h2 class="section-title">First Thing First</h2>

        <div class="duck-comment">
            <p>‚ñ∂ safety firzt!!</p>
        </div>
        
        <p>
            Create a strong password and encrypt it within a file, and then set the path for the file.<br>
            This password will be used for the dashboard and the API later on in this article.<br><br>
        </p>        

        <details class="code-block-container" open>
            <summary class="code-header">
                <div class="code-lang">‚ñ∂ Configure password</div>
            </summary>

            <div class="code-block">
                <pre>
<span class="duck-version"></span>
<span class="clean-version hidden"></span>
                </pre>

                <script type="text/plain" class="duck-source">
{ ü¶Üü¶Üü¶Üü¶Ü
  config,
  lib,
  self,
  pkgs,
  ...
} : { 
  house = {        
    dashboard = {
      passwordFile = config.sops.secrets.api.path;
    };
    
  };}  
                </script>

                <script type="text/plain" class="clean-source">
{
  config,
  lib,
  self,
  pkgs,
  ...
} : { 
  house = {        
    dashboard = {
      passwordFile = config.sops.secrets.api.path;
    };
    
  };}  
                </script>
            </div>
        </details>



        <br><br>
        <p>
            Since we will be executing shell commands from the chat, I added <strong>fun</strong> and proper authentication to the <a href="https://github.com/QuackHack-McBlindy/dotfiles/blob/main/bin/home/duckDash.nix">duckDash.nix</a> module in form of a login screen - and protected the webserver with it.<br>
            <br>
            If you are just following along this article and using my modules, you don't have to do this login page - as it is already implemented into the duckDash module, I just wanted to show it off - since security is major key.<br>
            And damnit, I won't lie.. I just love these falling ducks. They really make me smile every time I am prompted for the password.<br>
        </p>


        <details class="code-block-container">
            <summary class="code-header">
                <div class="code-lang">‚ñ∂ View Login Screen Code (duckDash.nix)</div>
            </summary>

            <div class="code-block">
                <pre>
<span class="duck-version"></span>
<span class="clean-version hidden"></span>
                </pre>

                <script type="text/plain" class="duck-source">
  # ü¶Ü says ‚ñ∂ ... rest of duckDash module

  login = ''
    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login</title>
    <style>
    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: monospace;
      background: black;
      position: relative;
    }
    
    .emoji {
      position: absolute;
      top: -50px;
      font-size: 2rem;
      animation: fall linear infinite;
    }
    
    .duck { font-size: 3rem; }
    
    .heart {
      font-size: 2rem;
      transition: transform 0.3s ease;
    }
    
    .heart:hover {
      transform: scale(2);
      opacity: 0;
    }
    
    @keyframes fall {
      to { transform: translateY(100vh); }
    }
    
    #beginButton {
      font-size: 2rem;
      padding: 12px 40px;
      background: linear-gradient(45deg, #00ff00, #00ccff, #ff00ff);
      background-size: 300% 300%;
      color: black;
      border: 2px solid #00FF00;
      border-radius: 12px;
      cursor: pointer;
      z-index: 300;
      animation: gradientAnimation 3s ease infinite, fadeIn 2s forwards;
      box-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #00ff00;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    #beginButton:hover {
      transform: scale(1.2) rotate(-5deg);
      box-shadow: 0 0 40px #00ff00, 0 0 80px #00ff00, 0 0 120px #00ff00;
    }
    
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
        
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    
    @keyframes flyAway {
      to {
        transform: translate(var(--x), var(--y)) scale(1.5) rotate(720deg);
        opacity: 0;
      }
    }
    
    #matrixScreen {
      display: none;
      position: fixed;
      inset: 0;
      background: black;
      color: #00ff00;
      font-size: 2rem;
      padding: 2rem;
      overflow: hidden;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    #matrixScreen.show {
      display: block;
      opacity: 1;
    }
    
    .cursor {
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      50% { opacity: 0; }
    }
    
    #loginPage {
      display: none;
      position: fixed;
      inset: 0;
      background: black;
      color: #00FF00;
      font-family: "Courier New", monospace;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    #loginPage.show {
      display: flex;
      opacity: 1;
    }
    
    .login-container {
      border: 2px solid #00FF00;
      padding: 20px;
      width: 300px;
      text-align: center;
    }
    
    .login-container h1 {
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .login-container input {
      background-color: black;
      border: 2px solid #00FF00;
      color: #00FF00;
      padding: 10px;
      width: 80%;
      margin: 10px;
      font-size: 16px;
      text-align: center;
    }
    
    .login-container input[type="submit"] {
      cursor: pointer;
      background-color: #00FF00;
      color: black;
      border: none;
      transition: all 0.3s ease;
    }
    
    .login-container input[type="submit"]:hover {
      background-color: #00CC00;
    }
    
    .message {
      font-size: 14px;
      margin-top: 20px;
      color: #FF4500;
    }
    
    .message a {
      color: #00FF00;
      text-decoration: none;
    }
    </style>
    </head>

    <body>
    
    <button id="beginButton">Login!</button>
    
    <div id="matrixScreen">
      <div id="matrixText"></div>
    </div>
    
    <div id="loginPage">
      <div class="login-container">
        <h1>Enter the System</h1>
        <form action="/submit" method="POST">
          <input type="password" name="password" placeholder="Password" required>
          <input type="submit" value="Log In">
        </form>
        <div class="message">
          <p>Warning: Unauthorized access will be logged and <strong>punished</strong> accordingly!</p>
        </div>
      </div>
    </div>
    
    <script>
    const emojis = ['ü¶Ü','ü¶Ü','ü¶Ü','ü¶Ü','‚ù§Ô∏è'];
        
    for (let i = 0; i < 200; i++) {
      const e = document.createElement('div');
      e.classList.add('emoji');    
      const type = emojis[Math.floor(Math.random() * emojis.length)];
      e.innerText = type;
    
      if (type === 'ü¶Ü') e.classList.add('duck');
      else e.classList.add('heart');
    
      e.style.left = Math.random() * 100 + 'vw';
      e.style.animationDuration = Math.random() * 3 + 5 + 's';
      e.style.animationDelay = Math.random() * 5 + 's';    
      document.body.appendChild(e);
    }
    
    document.getElementById('beginButton').addEventListener('click', function () {
      const emojis = document.querySelectorAll('.emoji');    
      emojis.forEach(e => {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        e.style.setProperty('--x', `''${x}px`);
        e.style.setProperty('--y', `''${y}px`);
        e.style.animation = 'flyAway 1.5s forwards';
      });
    
      this.style.display = 'none';
    
      setTimeout(() => {
        const matrix = document.getElementById('matrixScreen');
        matrix.classList.add('show');
        startMatrix();
      }, 1500);
    });
    
    function startMatrix() {
      const matrixText = document.getElementById('matrixText');    
      const lines = [
        '> enter authentication...',
      ];
    
      let i = 0;
      let j = 0;
    
      function type() {
        if (i >= lines.length) {
          setTimeout(fadeToLogin, 1500);
          return;
        }
    
        matrixText.innerHTML += lines[i][j] + '<span class="cursor">‚ñà</span>';
        j++;
        if (j === lines[i].length) {
          matrixText.innerHTML += '<br>';
          i++;
          j = 0;
        }
        setTimeout(type, 30);
      }    
      type();
    }
    
    function fadeToLogin() {
      const matrix = document.getElementById('matrixScreen');
      const login = document.getElementById('loginPage');
      matrix.style.opacity = 0;
      setTimeout(() => {
        matrix.style.display = 'none';
        login.style.display = 'flex';
    
        setTimeout(() => {
          login.classList.add('show');
        }, 50);
    
      }, 2000);
    }
    </script> 
    </body>
    </html>
  '';

                </script>

                <script type="text/plain" class="clean-source">
  # ... rest of duckDash module

  login = ''
    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login</title>
    <style>
    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: monospace;
      background: black;
      position: relative;
    }
    
    .emoji {
      position: absolute;
      top: -50px;
      font-size: 2rem;
      animation: fall linear infinite;
    }
    
    .duck { font-size: 3rem; }
    
    .heart {
      font-size: 2rem;
      transition: transform 0.3s ease;
    }
    
    .heart:hover {
      transform: scale(2);
      opacity: 0;
    }
    
    @keyframes fall {
      to { transform: translateY(100vh); }
    }
    
    #beginButton {
      font-size: 2rem;
      padding: 12px 40px;
      background: linear-gradient(45deg, #00ff00, #00ccff, #ff00ff);
      background-size: 300% 300%;
      color: black;
      border: 2px solid #00FF00;
      border-radius: 12px;
      cursor: pointer;
      z-index: 300;
      animation: gradientAnimation 3s ease infinite, fadeIn 2s forwards;
      box-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #00ff00;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    #beginButton:hover {
      transform: scale(1.2) rotate(-5deg);
      box-shadow: 0 0 40px #00ff00, 0 0 80px #00ff00, 0 0 120px #00ff00;
    }
    
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
        
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    
    @keyframes flyAway {
      to {
        transform: translate(var(--x), var(--y)) scale(1.5) rotate(720deg);
        opacity: 0;
      }
    }
    
    #matrixScreen {
      display: none;
      position: fixed;
      inset: 0;
      background: black;
      color: #00ff00;
      font-size: 2rem;
      padding: 2rem;
      overflow: hidden;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    #matrixScreen.show {
      display: block;
      opacity: 1;
    }
    
    .cursor {
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      50% { opacity: 0; }
    }
    
    #loginPage {
      display: none;
      position: fixed;
      inset: 0;
      background: black;
      color: #00FF00;
      font-family: "Courier New", monospace;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    #loginPage.show {
      display: flex;
      opacity: 1;
    }
    
    .login-container {
      border: 2px solid #00FF00;
      padding: 20px;
      width: 300px;
      text-align: center;
    }
    
    .login-container h1 {
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .login-container input {
      background-color: black;
      border: 2px solid #00FF00;
      color: #00FF00;
      padding: 10px;
      width: 80%;
      margin: 10px;
      font-size: 16px;
      text-align: center;
    }
    
    .login-container input[type="submit"] {
      cursor: pointer;
      background-color: #00FF00;
      color: black;
      border: none;
      transition: all 0.3s ease;
    }
    
    .login-container input[type="submit"]:hover {
      background-color: #00CC00;
    }
    
    .message {
      font-size: 14px;
      margin-top: 20px;
      color: #FF4500;
    }
    
    .message a {
      color: #00FF00;
      text-decoration: none;
    }
    </style>
    </head>

    <body>
    
    <button id="beginButton">Login!</button>
    
    <div id="matrixScreen">
      <div id="matrixText"></div>
    </div>
    
    <div id="loginPage">
      <div class="login-container">
        <h1>Enter the System</h1>
        <form action="/submit" method="POST">
          <input type="password" name="password" placeholder="Password" required>
          <input type="submit" value="Log In">
        </form>
        <div class="message">
          <p>Warning: Unauthorized access will be logged and <strong>punished</strong> accordingly!</p>
        </div>
      </div>
    </div>
    
    <script>
    const emojis = ['ü¶Ü','ü¶Ü','ü¶Ü','ü¶Ü','‚ù§Ô∏è'];
        
    for (let i = 0; i < 200; i++) {
      const e = document.createElement('div');
      e.classList.add('emoji');    
      const type = emojis[Math.floor(Math.random() * emojis.length)];
      e.innerText = type;
    
      if (type === 'ü¶Ü') e.classList.add('duck');
      else e.classList.add('heart');
    
      e.style.left = Math.random() * 100 + 'vw';
      e.style.animationDuration = Math.random() * 3 + 5 + 's';
      e.style.animationDelay = Math.random() * 5 + 's';    
      document.body.appendChild(e);
    }
    
    document.getElementById('beginButton').addEventListener('click', function () {
      const emojis = document.querySelectorAll('.emoji');    
      emojis.forEach(e => {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        e.style.setProperty('--x', `''${x}px`);
        e.style.setProperty('--y', `''${y}px`);
        e.style.animation = 'flyAway 1.5s forwards';
      });
    
      this.style.display = 'none';
    
      setTimeout(() => {
        const matrix = document.getElementById('matrixScreen');
        matrix.classList.add('show');
        startMatrix();
      }, 1500);
    });
    
    function startMatrix() {
      const matrixText = document.getElementById('matrixText');    
      const lines = [
        '> enter authentication...',
      ];
    
      let i = 0;
      let j = 0;
    
      function type() {
        if (i >= lines.length) {
          setTimeout(fadeToLogin, 1500);
          return;
        }
    
        matrixText.innerHTML += lines[i][j] + '<span class="cursor">‚ñà</span>';
        j++;
        if (j === lines[i].length) {
          matrixText.innerHTML += '<br>';
          i++;
          j = 0;
        }
        setTimeout(type, 30);
      }    
      type();
    }
    
    function fadeToLogin() {
      const matrix = document.getElementById('matrixScreen');
      const login = document.getElementById('loginPage');
      matrix.style.opacity = 0;
      setTimeout(() => {
        matrix.style.display = 'none';
        login.style.display = 'flex';
    
        setTimeout(() => {
          login.classList.add('show');
        }, 50);
    
      }, 2000);
    }
    </script>
    </body>
    </html>
  '';

                </script>
            </div>
        </details><br><br>

        <video width="400" controls>
            <source src="https://raw.githubusercontent.com/QuackHack-McBlindy/blog/main/img/login.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video> <br><br>


        <h2 class="section-title">This Might Require An API?</h2>
        
        <p>
            This might not be a requirement, but I felt it was the way to go for me - if I was not going to need it now, I most likely would need it later in some form.<br>
            So I wrote a Rust service with a endpoint for the `yo do` <i>(the NLP)</i> command, some zigbee device control endpoints and filled it with some other endpoints that I might need in the future, and password protected them, so no sketchy intruders can use them.<br>
        </p>



        <details class="code-block-container">
            <summary class="code-header">
                <div class="code-lang">‚ñ∂ View API Endpoints Code in RUst</div>
            </summary>

            <div class="code-block">
                <pre>
<span class="duck-version"></span>
<span class="clean-version hidden"></span>
                </pre>

                <script type="text/plain" class="duck-source">
# dotfiles/bin/network/api.nix ‚Æû https://github.com/quackhack-mcblindy/dotfiles
{ # ü¶Ü says ‚Æû home automation API endpoints, written in Rust
  self,
  lib,
  config,
  pkgs,
  cmdHelpers,
  RustDuckTrace,
  ...
} : let     
  # ü¶Ü says ‚Æû dis fetch what host has Mosquitto
  sysHosts = lib.attrNames self.nixosConfigurations; 
  mqttHost = lib.findSingle (host:
      let cfg = self.nixosConfigurations.${host}.config;
      in cfg.services.mosquitto.enable or false
    ) null null sysHosts;    
  mqttHostip = if mqttHost != null
    then self.nixosConfigurations.${mqttHost}.config.this.host.ip or (
      let
        resolved = builtins.readFile (pkgs.runCommand "resolve-host" {} ''
          ${pkgs.dnsutils}/bin/host -t A ${mqttHost} > $out
        '');
      in
        lib.lists.head (lib.strings.splitString " " (lib.lists.elemAt (lib.strings.splitString "\n" resolved) 0))
    )
    else (throw "No Mosquitto host found in configuration");
  mqttAuth = "-u mqtt -P $(cat ${config.sops.secrets.mosquitto.path})";
    
  # ü¶Ü says ‚Æû define Zigbee devices here yo 
  zigbeeDevices = config.house.zigbee.devices;
  
  # ü¶Ü says ‚Æû case-insensitive device matching
  normalizedDeviceMap = lib.mapAttrs' (id: device:
    lib.nameValuePair (lib.toLower device.friendly_name) device.friendly_name
  ) zigbeeDevices;

  # ü¶Ü says ‚Æû device validation list
  deviceList = builtins.attrNames normalizedDeviceMap;

  # ü¶Ü says ‚Æû scene simplifier? or not
  sceneLight = {state, brightness ? 200, hex ? null, temp ? null}:
    let
      colorValue = if hex != null then { inherit hex; } else null;
    in
    {
      inherit state brightness;
    } // (if colorValue != null then { color = colorValue; } else {})
      // (if temp != null then { color_temp = temp; } else {});

  # üé® Scenes  ü¶Ü YELLS ‚Æû SCENES!!!!!!!!!!!!!!!11
  scenes = config.house.zigbee.scenes; # ü¶Ü says ‚Æû Declare light states, quack dat's a scene yo!   

  # ü¶Ü says ‚Æû Generate scene commands    
  makeCommand = device: settings:
    let
      json = builtins.toJSON settings;
    in
      ''
      yo mqtt_pub --topic "zigbee2mqtt/${device}/set" --message '${json}'
      '';
      
  sceneCommands = lib.mapAttrs
    (sceneName: sceneDevices:
      lib.mapAttrs (device: settings: makeCommand device settings) sceneDevices
    ) scenes;  

  # ü¶Ü says ‚Æû Filter devices by rooms
  byRoom = lib.foldlAttrs (acc: id: dev:
    lib.recursiveUpdate acc {
      ${dev.room} = (acc.${dev.room} or []) ++ [ id ];
    }) {} zigbeeDevices;

  # ü¶Ü says ‚Æû Filter by device type
  byType = lib.foldlAttrs (acc: id: dev:
    lib.recursiveUpdate acc {
      ${dev.type} = (acc.${dev.type} or []) ++ [ id ];
    }) {} zigbeeDevices;

  # ü¶Ü says ‚Æû dis creates group configuration for Z2M yo
  groupConfig = lib.mapAttrs' (room: ids: {
    name = room;
    value = {
      friendly_name = room;
      devices = map (id: 
        let dev = zigbeeDevices.${id};
        in "${id}/${toString dev.endpoint}"
      ) ids;
    };
  }) byRoom;

  # ü¶Ü says ‚Æû gen json from `config.house.tv`  
  tvDevicesJson = pkgs.writeText "tv-devices.json" (builtins.toJSON config.house.tv);

  # ü¶Ü says ‚Æû dis creates device configuration for Z2M yo
  deviceConfig = lib.mapAttrs (id: dev: {
    friendly_name = dev.friendly_name;
  }) zigbeeDevices;

  # ü¶Ü says ‚Æû IEEE not very human readable - lets fix dat yo
  ieeeToFriendly = lib.mapAttrs (ieee: dev: dev.friendly_name) zigbeeDevices;
  mappingJSON = builtins.toJSON ieeeToFriendly;
  mappingFile = pkgs.writeText "ieee-to-friendly.json" mappingJSON;

  # ü¶Ü says ‚Æû not to be confused with facebook - this is not even duckbook
  deviceMeta = builtins.toJSON (
    lib.listToAttrs (
      lib.filter (attr: attr.name != null) (
        lib.mapAttrsToList (_: dev: {
          name = dev.friendly_name;
          value = {
            room = dev.room;
            type = dev.type;
            id = dev.friendly_name;
            endpoint = dev.endpoint;
          };
        }) zigbeeDevices
      )
    )
  );# ü¶Ü says ‚Æû yaaaaaaaaaaaaaaay

  # ü¶Ü says ‚Æû Generate automations configuration
  automationsJSON = builtins.toJSON config.house.zigbee.automations;
  automationsFile = pkgs.writeText "automations.json" automationsJSON;

  # ü¶Ü says ‚Æû Dark time enabled flag
  darkTimeEnabled = if config.house.zigbee.darkTime.enable then "1" else "0";

  # ü¶Ü needz 4 rust  
  devices-json = pkgs.writeText "devices.json" deviceMeta;

  scenes-json = pkgs.writeText "scenes.json" (builtins.toJSON sceneCommands);
  rooms-json = pkgs.writeText "rooms.json" (builtins.toJSON (
    lib.mapAttrs (room: devices: {
      inherit room;
      devices = map (id: zigbeeDevices.${id}.friendly_name) devices;
    }) byRoom
  ));
  types-json = pkgs.writeText "types.json" (builtins.toJSON (
    lib.mapAttrs (type: devices: {
      inherit type;
      devices = map (id: zigbeeDevices.${id}.friendly_name) devices;
    }) byType
  ));

  #  ü¶Ü says ‚Æû API   
  cargo-toml = pkgs.writeText "Cargo.toml" ''
    [package]
    name = "api-rs"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    serde_json = "1.0"
    chrono = { version = "0.4", features = ["serde"] }
    multipart = "0.18"
    colored = "2.1" 
  ''; 

  api-rs = pkgs.writeText "api.rs" ''
    ${RustDuckTrace}

    use std::io::{BufRead, BufReader, Read};
    use std::net::{TcpListener, TcpStream};
    use std::process::Command;
    use std::collections::HashMap;
    use std::fs::{self, create_dir_all};
    use serde_json::json;
    

    fn log(message: &str) {
        eprintln!("[API] {}", message);
    }

    // ü¶Ü says ‚Æû Password authentication function
    fn check_password_auth(headers: &HashMap<String, String>, query: &str) -> bool {
        let password_file_path = std::env::var("YO_API_PASSWORD_FILE")
            .unwrap_or_else(|_| "${config.house.dashboard.passwordFile}".to_string());
        
        let expected_password = match std::fs::read_to_string(&password_file_path) {
            Ok(content) => content.trim().to_string(),
            Err(_) => {
                log(&format!("Warning: Could not read password file: {}", password_file_path));
                return false;
            }
        };
        
        if let Some(auth_header) = headers.get("authorization") {
            if auth_header.starts_with("Bearer ") {
                let provided_password = auth_header[7..].trim();
                return provided_password == expected_password;
            } else if auth_header.starts_with("Password ") {
                let provided_password = auth_header[9..].trim();
                return provided_password == expected_password;
            }
        }
        
        let query_password = get_query_arg(query, "password");
        if !query_password.is_empty() && query_password == expected_password {
            return true;
        }
        
        if let Some(api_key) = headers.get("x-api-key") {
            return api_key.trim() == expected_password;
        }       
        false
    }
        
    fn urldecode(s: &str) -> String {
        let mut result = Vec::new();
        let bytes = s.bytes().collect::<Vec<_>>();
        let mut i = 0;
    
        while i < bytes.len() {
            match bytes[i] {
                b'%' if i + 2 < bytes.len() => {
                    if let (Some(high), Some(low)) = (from_hex(bytes[i + 1]), from_hex(bytes[i + 2])) {
                        let byte = (high << 4) | low;
                        result.push(byte);
                        i += 3;
                        continue;
                    }
                }
                b'+' => {
                    result.push(b' ');
                }
                _ => {
                    result.push(bytes[i]);
                }
            }
            i += 1;
        }
    
        String::from_utf8(result).unwrap_or_else(|_| s.to_string())
    }
    
    fn from_hex(byte: u8) -> Option<u8> {
        match byte {
            b'0'..=b'9' => Some(byte - b'0'),
            b'a'..=b'f' => Some(byte - b'a' + 10),
            b'A'..=b'F' => Some(byte - b'A' + 10),
            _ => None,
        }
    }
    
    fn send_response(stream: &mut TcpStream, status: &str, body: &str, content_type: Option<&str>) {
        let content_type = content_type.unwrap_or("application/json");
        let response = format!(
            "HTTP/1.1 {}\r\n\
             Content-Type: {}\r\n\
             Access-Control-Allow-Origin: *\r\n\
             Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n\
             Access-Control-Allow-Headers: Authorization, Content-Type, X-API-Key\r\n\
             Content-Length: {}\r\n\r\n{}",
            status,
            content_type,
            body.len(),
            body
        );
        if let Err(e) = stream.write_all(response.as_bytes()) {
            dt_warning(&format!("Failed to send response: {}", e));
        }
    }
    
    fn get_query_arg(query: &str, arg_name: &str) -> String {
        let parts: Vec<&str> = query.split('&').collect();
        for part in parts {
            if part.starts_with(&format!("{}=", arg_name)) {
                let encoded = &part[arg_name.len() + 1..];
                return urldecode(encoded);
            }
        }
        String::new()
    }
    
    fn get_path_arg(query: &str) -> String {
        let parts: Vec<&str> = query.split('&').collect();
        for part in parts {
            if part.starts_with("path=") {
                let encoded = &part[5..];
                return urldecode(encoded);
            }
        }
        String::new()
    }
    
    fn handle_browse(path_arg: &str, use_v2: bool) -> String {
        let media_root = "/Pool";
        let full_path = format!("{}/{}", media_root, path_arg);
        
        // ü¶Ü says ‚Æû safety first!
        if !full_path.starts_with(media_root) {
            dt_warning(&format!("Access forbidden for path: {}", path_arg));
            return r#"{"error":"Access forbidden"}"#.to_string();
        }
    
        let path_std = std::path::Path::new(&full_path);
        if !path_std.exists() || !path_std.is_dir() {
            return format!(r#"{{"error":"Directory not found: {}"}}"#, path_arg);
        }
    
        let mut directories = Vec::new();
        let mut files = Vec::new();
    
        if use_v2 {
            // ü¶Ü says ‚Æû browsev2 with find
            let output = Command::new("find")
                .arg(&full_path)
                .arg("-maxdepth")
                .arg("1")
                .arg("-mindepth")
                .arg("1")
                .output();
            
            match output {
                Ok(output) if output.status.success() => {
                    let output_str = String::from_utf8_lossy(&output.stdout);
                    for line in output_str.lines() {
                        if line.is_empty() { continue; }
                        let item_path = std::path::Path::new(line);
                        if let Some(name) = item_path.file_name().and_then(|n| n.to_str()) {
                            if item_path.is_dir() {
                                directories.push(name.to_string());
                            } else {
                                files.push(name.to_string());
                            }
                        }
                    }
                }
                _ => return r#"{"error":"Failed to list directory"}"#.to_string(),
            }
        } else {
            // ü¶Ü says ‚Æû browse logic with ls
            let output = Command::new("ls")
                .arg("-1")
                .arg(&full_path)
                .output();
            
            match output {
                Ok(output) if output.status.success() => {
                    let output_str = String::from_utf8_lossy(&output.stdout);
                    for item in output_str.lines() {
                        if item.is_empty() { continue; }
                        let item_path = path_std.join(item);
                        if item_path.is_dir() {
                            directories.push(item.to_string());
                        } else {
                            files.push(item.to_string());
                        }
                    }
                }
                _ => return r#"{"error":"Failed to list directory"}"#.to_string(),
            }
        }
    
        directories.sort();
        files.sort();
    
        let dirs_json = serde_json::to_string(&directories).unwrap_or_else(|_| "[]".to_string());
        let files_json = serde_json::to_string(&files).unwrap_or_else(|_| "[]".to_string());
    
        if use_v2 {
            let real_full_path = path_std.canonicalize().unwrap_or_else(|_| path_std.to_path_buf());
            format!(
                r#"{{"path":"{}","full_path":"{}","directories":{},"files":{}}}"#,
                path_arg,
                real_full_path.display(),
                dirs_json,
                files_json
            )
        } else {
            format!(
                r#"{{"path":"{}","directories":{},"files":{}}}"#,
                path_arg,
                dirs_json,
                files_json
            )
        }
    }
    
    fn run_yo_command(args: &[&str]) -> Result<String, String> {
        let output = Command::new("yo")
            .args(args)
            .output()
            .map_err(|e| format!("Failed to execute yo command: {}", e))?;
        
        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(String::from_utf8_lossy(&output.stderr).to_string())
        }
    }

    fn handle_file_upload(headers: &HashMap<String, String>, body: &[u8]) -> String {
        let uploads_dir = "/var/lib/zigduck/uploads";
        if let Err(e) = create_dir_all(uploads_dir) {
            return format!(r#"{{"error":"Failed to create uploads directory: {}"}}"#, e);
        }
    
        let content_type = headers.get("content-type").unwrap_or(&String::new()).clone();
        
        if !content_type.contains("multipart/form-data") {
            return r#"{"error":"Only multipart/form-data uploads are supported"}"#.to_string();
        }
        
        let boundary = if let Some(idx) = content_type.find("boundary=") {
            content_type[idx + "boundary=".len()..].trim().to_string()
        } else {
            return r#"{"error":"No boundary in Content-Type"}"#.to_string();
        };
        
        dt_debug(&format!("Boundary: {}", boundary));
        
        let body_str = match String::from_utf8(body.to_vec()) {
            Ok(s) => s,
            Err(_) => return r#"{"error":"Body is not valid UTF-8"}"#.to_string(),
        };
        
        let boundary_marker = format!("--{}", boundary);
        let parts: Vec<&str> = body_str.split(&boundary_marker).collect();
        
        dt_debug(&format!("Found {} parts", parts.len()));
        
        for (i, part) in parts.iter().enumerate().skip(1) {
            if i == parts.len() - 1 && part.trim().ends_with("--") {
                continue;
            }
            
            let part = part.trim();
            if part.is_empty() {
                continue;
            }
            
            log(&format!("Part {}: {} chars", i, part.len()));
            
            if let Some(idx) = part.find("\r\n\r\n") {
                let headers_part = &part[..idx];
                let content_start = idx + 4;
                let content = &part[content_start..];
                
                let mut filename = None;
                for line in headers_part.split("\r\n") {
                    if line.to_lowercase().contains("filename=") {
                        if let Some(start_idx) = line.find("filename=\"") {
                            let start = start_idx + "filename=\"".len();
                            if let Some(end_idx) = line[start..].find('\"') {
                                filename = Some(line[start..start + end_idx].to_string());
                                break;
                            }
                        }
                    }
                }
                
                if let Some(original_filename) = filename {
                    // ü¶Ü says ‚Æû helper 2 get unique filename
                    fn get_unique_filename(dir: &str, base: &str) -> Result<String, String> {
                        use std::path::Path;               
                        const MAX_ATTEMPTS: usize = 1000;
                        
                        let path = Path::new(base);
                        let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or("file");
                        let ext = path.extension().and_then(|s| s.to_str()).unwrap_or("");
                        
                        let mut candidate = base.to_string();
                        let mut full_path = Path::new(dir).join(&candidate);
                        
                        if !full_path.exists() {
                            dt_debug(&format!("Base filename available: {}", candidate));
                            return Ok(candidate);
                        }
                        
                        dt_info(&format!("Base filename exists: {}, generating unique name", candidate));
                        
                        for counter in 1..=MAX_ATTEMPTS {
                            candidate = if ext.is_empty() {
                                format!("{}({})", stem, counter)
                            } else {
                                format!("{}({}).{}", stem, counter, ext)
                            };
                            
                            full_path = Path::new(dir).join(&candidate);
                            if !full_path.exists() {
                                log(&format!("Found unique filename: {}", candidate));
                                return Ok(candidate);
                            }
                        }               
                        Err(format!("Could not find unique filename after {} attempts", MAX_ATTEMPTS))
                    }
                    
                    let sanitized = sanitize_filename(&original_filename);
                    log(&format!("Sanitized filename: {}", sanitized));
                    
                    match get_unique_filename(uploads_dir, &sanitized) {
                        Ok(unique_name) => {
                            let destination = format!("{}/{}", uploads_dir, unique_name);
                            let clean_content = content.trim_end_matches("\r\n");
                            
                            log(&format!("Writing {} bytes to {}", clean_content.len(), destination));
                            
                            match std::fs::write(&destination, clean_content) {
                                Ok(_) => {
                                    let file_size = clean_content.len();
                                    
                                    let response = json!({
                                        "status": "success",
                                        "message": "File uploaded successfully",
                                        "files": [{
                                            "filename": unique_name,
                                            "original_filename": original_filename,
                                            "size": file_size,
                                            "path": destination
                                        }]
                                    }).to_string();
                                    
                                    dt_info(&format!("Upload successful: {}", response));
                                    return response;
                                }
                                Err(e) => {
                                    let error_msg = format!(r#"{{"error":"Failed to write file: {}"}}"#, e);
                                    log(&format!("Write error: {}", error_msg));
                                    return error_msg;
                                }
                            }
                        }
                        Err(e) => {
                            let error_msg = format!(r#"{{"error":"{}"}}"#, e);
                            log(&format!("Unique filename error: {}", error_msg));
                            return error_msg;
                        }
                    }
                }
            }
        }   
        r#"{"error":"No file found in upload"}"#.to_string()
    }

    fn sanitize_filename(filename: &str) -> String {
        let mut sanitized = String::new();
        for c in filename.chars() {
            if c.is_alphanumeric() || c == '.' || c == '-' || c == '_' {
                sanitized.push(c);
            } else if c == ' ' {
                sanitized.push('_');
            }
        }    
        // ü¶Ü says ‚Æû make sure we have at least something
        if sanitized.is_empty() {
            format!("file_{}.bin", chrono::Local::now().format("%Y%m%d_%H%M%S"))
        } else {
            sanitized
        }
    }
      
    fn handle_shopping_list() -> String {
        match run_yo_command(&["shop-list", "--list"]) {
            Ok(output) => {
                let items: Vec<&str> = output.lines().collect();
                match serde_json::to_string(&items) {
                    Ok(json_items) => format!(r#"{{"items":{}}}"#, json_items),
                    Err(_) => r#"{"error":"Failed to format shopping list"}"#.to_string(),
                }
            }
            Err(_) => r#"{"error":"Failed to fetch shopping list"}"#.to_string(),
        }
    }
    
    fn handle_reminders() -> String {
        match run_yo_command(&["reminder", "--list"]) {
            Ok(output) => {
                let items: Vec<&str> = output.lines().collect();
                match serde_json::to_string(&items) {
                    Ok(json_items) => format!(r#"{{"items":{}}}"#, json_items),
                    Err(_) => r#"{"error":"Failed to format reminders"}"#.to_string(),
                }
            }
            Err(_) => r#"{"error":"Failed to fetch reminders"}"#.to_string(),
        }
    }
    
    // ü¶Ü says ‚Æû device control endpoints
    fn handle_device_list() -> String {
        match fs::read_to_string("devices.json") {
            Ok(content) => content,
            Err(_) => r#"{"error":"Devices file not found"}"#.to_string(),
        }
    }
            
    fn handle_device_rest_control(path: &str) -> String {
        dt_info(&format!("Device control request: {}", path));    
        let segments: Vec<&str> = path.split('/').collect();
        
        if segments.is_empty() {
            dt_warning("Device control called without device name");
            return r#"{"error":"Missing device name"}"#.to_string();
        }
        
        let device_name = urldecode(segments[0]);
        dt_info(&format!("Controlling device: {}", device_name));
        
        let mut commands = Vec::new();
        let mut i = 1;
        
        while i < segments.len() {
            if i + 1 < segments.len() {
                let action = segments[i];
                let value = urldecode(segments[i + 1]);
                commands.push((action, value));
                i += 2;
            } else {
                return r#"{"error":"Malformed command path"}"#.to_string();
            }
        }
        
        if commands.is_empty() {
            return r#"{"error":"No commands specified"}"#.to_string();
        }
        
        handle_device_combined_control(&device_name, &commands)
    }
    
    fn handle_device_combined_control(device_name: &str, commands: &[(&str, String)]) -> String {
        dt_info(&format!("Device '{}' commands: {:?}", device_name, commands)); 
        let devices_json = fs::read_to_string("devices.json").unwrap_or_else(|_| "{}".to_string());
        let devices: HashMap<String, serde_json::Value> = serde_json::from_str(&devices_json).unwrap_or_default();
    
        let mut found_device = None;
        for (dev_name, _) in &devices {
            if dev_name.to_lowercase() == device_name.to_lowercase() {
                found_device = Some(dev_name);
                break;
            }
        }
    
        match found_device {
            Some(actual_name) => {
                let mut message = HashMap::new();
                
                for (action, value) in commands {
                    match *action {
                        "state" => {
                            match value.to_lowercase().as_str() {
                                "on" => {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                                "off" => {
                                    message.insert("state".to_string(), "OFF".to_string());
                                }
                                _ => return format!(r#"{{"error":"Invalid state value: {}"}}"#, value),
                            }
                        }
                        "brightness" => {
                            if let Ok(brightness) = value.parse::<u16>() {
                                message.insert("brightness".to_string(), brightness.to_string());

                                if !message.contains_key("state") {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                            } else {
                                return format!(r#"{{"error":"Invalid brightness value: {}"}}"#, value);
                            }
                        }
                        "color" | "colour" => {
                            let hex_value = if value.starts_with('#') { value.clone() } else { format!("#{}", value) };
                            if hex_value.len() == 7 {
                                let color_map = HashMap::from([("hex".to_string(), hex_value)]);
                                message.insert("color".to_string(), serde_json::to_string(&color_map).unwrap());

                                if !message.contains_key("state") {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                            } else {
                                return format!(r#"{{"error":"Invalid color format, use #RRGGBB or RRGGBB"}}"#);
                            }
                        }
                        "temperature" | "temp" | "color_temp" => {
                            if let Ok(temp) = value.parse::<u16>() {
                                message.insert("color_temp".to_string(), temp.to_string());
                                if !message.contains_key("state") {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                            } else {
                                return format!(r#"{{"error":"Invalid temperature value: {}"}}"#, value);
                            }
                        }
                        _ => return format!(r#"{{"error":"Unknown action: {}"}}"#, action),
                    }
                }
                
                let message_json = serde_json::to_string(&message).unwrap_or_else(|_| "{}".to_string());
                let topic = format!("zigbee2mqtt/{}/set", actual_name);
                
                match run_yo_command(&["mqtt_pub", "--topic", &topic, "--message", &message_json]) {
                    Ok(_) => {
                        let command_list: Vec<String> = commands.iter()
                            .map(|(a, v)| format!("{}:{}", a, v))
                            .collect();
                        format!(r#"{{"status":"ok","device":"{}","commands":{}}}"#, 
                            actual_name, serde_json::to_string(&command_list).unwrap())
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to control device '{}': {}", actual_name, e));
                        format!(r#"{{"error":"Failed to control device: {}"}}"#, e)
                    }
                }
            }
            None => format!(r#"{{"error":"Device not found: {}"}}"#, device_name),
        }
    }
        
    fn handle_scene_activate(scene_name: &str) -> String {
        if scene_name.is_empty() {
            dt_warning("Scene activation called with empty scene name");
            return r#"{"error":"Missing scene name"}"#.to_string();
        }

        dt_info(&format!("Activating scene: {}", scene_name));
        // ü¶Ü says ‚Æû load scenes from json
        let scenes_content = match fs::read_to_string("scenes.json") {
            Ok(content) => content,
            Err(_) => {
                dt_error("Scenes file not found");
                return r#"{"error":"Scenes file not found"}"#.to_string();
            }
        };

        let scenes_map: HashMap<String, serde_json::Value> = 
            serde_json::from_str(&scenes_content).unwrap_or_default();

        // ü¶Ü says ‚Æû lowercase mappin'
        let mut scene_lowercase_map = HashMap::new();
        for (scene_key, _) in &scenes_map {
            scene_lowercase_map.insert(scene_key.to_lowercase(), scene_key.clone());
        }

        let normalized_scene_name = scene_name.to_lowercase();
    
        match scene_lowercase_map.get(&normalized_scene_name) {
            Some(actual_scene_name) => {
                match run_yo_command(&["house", "--scene", actual_scene_name]) {
                    Ok(_) => format!(r#"{{"status":"ok","scene":"{}"}}"#, actual_scene_name),
                    Err(e) => format!(r#"{{"error":"Failed to activate scene: {}"}}"#, e),
                }
            }
            None => format!(r#"{{"error":"Scene not found: {}"}}"#, scene_name),
        }
    }
    
    fn handle_rooms_list() -> String {
        match fs::read_to_string("rooms.json") {
            Ok(content) => content,
            Err(_) => r#"{"error":"Rooms data not available"}"#.to_string(),
        }
    }
    
    fn handle_types_list() -> String {
        match fs::read_to_string("types.json") {
            Ok(content) => content,
            Err(_) => r#"{"error":"Types data not available"}"#.to_string(),
        }
    }
    
    fn handle_health_check() -> String {
        match Command::new("health").output() {
            Ok(output) if output.status.success() => {
                let health_output = String::from_utf8_lossy(&output.stdout);
                // ü¶Ü says ‚Æû health script already returns JSON, so we can use it directly
                health_output.to_string()
            }
            Ok(output) => {
                let error_msg = String::from_utf8_lossy(&output.stderr);
                // ü¶Ü says ‚Æû fallback if health command fails
                let timestamp = chrono::Local::now().format("%Y-%m-%dT%H:%M:%S%z").to_string();
                format!(
                    r#"{{"status":"degraded","service":"yo-api","timestamp":"{}","error":"Health check failed: {}"}}"#,
                    timestamp, error_msg
                )
            }
            Err(e) => {
                // ü¶Ü says ‚Æû fallback if health command not found
                let timestamp = chrono::Local::now().format("%Y-%m-%dT%H:%M:%S%z").to_string();
                format!(
                    r#"{{"status":"degraded","service":"yo-api","timestamp":"{}","error":"Health command failed: {}"}}"#,
                    timestamp, e
                )
            }
        }
    }

    fn handle_health_all() -> String {
        let health_dir = "/var/lib/zigduck/health";
        let mut health_data = std::collections::HashMap::new();

        if let Ok(entries) = std::fs::read_dir(health_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("json") {
                    if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                        if let Ok(content) = std::fs::read_to_string(&path) {
                            if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                                health_data.insert(file_stem.to_string(), json);
                            }
                        }
                    }
                }
            }
        }

        match serde_json::to_string(&health_data) {
            Ok(json) => json,
            Err(_) => r#"{"error":"Failed to serialize health data"}"#.to_string(),
        }
    }
    
    fn handle_request(mut stream: TcpStream) {
        let peer_addr = match stream.peer_addr() {
            Ok(addr) => addr.to_string(),
            Err(_) => "unknown".to_string(),
        };

        let mut reader = BufReader::new(&stream);
        let mut request_line = String::new();
        
        // ü¶Ü says ‚Æû read request line
        if reader.read_line(&mut request_line).is_err() || request_line.is_empty() {
            log("No data on stdin; exiting");
            return;
        }
        // ü¶Ü says ‚Æû log requester ip
        dt_info(&format!("[{}] Request: {}", peer_addr, request_line.trim()));
        
        log(&format!("Request: {}", request_line.trim()));
    
        let parts: Vec<&str> = request_line.split_whitespace().collect();
        if parts.len() < 2 {
            return;
        }
    
        let method = parts[0];
        let raw_path = parts[1];
    
        // ü¶Ü says ‚Æû read headers
        let mut content_length = 0;
        let mut headers = HashMap::new();
        let mut header_line = String::new();
        loop {
            header_line.clear();
            if reader.read_line(&mut header_line).is_err() || header_line.is_empty() {
                break;
            }
            if header_line == "\r\n" || header_line == "\n" {
                break;
            }
            
            if let Some((key, value)) = header_line.split_once(':') {
                let key_lower = key.trim().to_lowercase();
                let value_trimmed = value.trim().to_string();
                
                if key_lower == "content-length" {
                    content_length = value_trimmed.parse().unwrap_or(0);
                }
                
                headers.insert(key_lower, value_trimmed);
            }
        }
    
        // ü¶Ü says ‚Æû read body if present
        let mut body = Vec::new();
        if content_length > 0 {
            let mut body_buf = vec![0; content_length];
            if let Ok(()) = reader.read_exact(&mut body_buf) {
                body = body_buf;
                log(&format!("Body size: {} bytes", body.len()));
            }
        }
    
        // ü¶Ü says ‚Æû parse path and query
        let (path_no_query, query) = match raw_path.split_once('?') {
            Some((path, query)) => (path, query),
            None => (raw_path, ""),
        };
    
        // ü¶Ü says ‚Æû exclude authentication for health
        if path_no_query != "/health" && path_no_query != "/health/all" && !check_password_auth(&headers, query) {
            send_response(&mut stream, "401 Unauthorized", 
                r#"{"error":"Authentication required","message":"Valid password required in Authorization: Bearer <password> header, X-API-Key header, or ?password= query parameter"}"#, 
                None);
            return;
        }
    
        // ü¶Ü says ‚Æû route the request
        match (method, path_no_query) {
            // ü¶Ü says ‚Æû handle CORS preflight
            ("OPTIONS", _) => {
                dt_debug("CORS preflight request");
                send_response(&mut stream, "200 OK", "", None);
                return;
            }
        
            ("GET", "/") => {
                dt_info("Root endpoint requested");
                send_response(&mut stream, "200 OK", 
                    r#"{"service":"yo-api","endpoints":["/timers","/alarms","/shopping","/reminders","/health","/browse","/browsev2","/add","/add_folder","/playlist","/playlist/remove","/playlist/clear","/playlist/shuffle","/do","/device/list","/device/{device}/...","/scene/{scene}","/device/rooms","/device/types","/upload","/tts"]}"#,
                    None);
            }
            ("GET", "/browsev2") | ("GET", "/api/browsev2") => {
                let path_arg = get_path_arg(query);
                let response = handle_browse(&path_arg, true);
                send_response(&mut stream, "200 OK", &response, None);
            }
            ("GET", "/browse") | ("GET", "/api/browse") => {
                let path_arg = get_path_arg(query);
                let response = handle_browse(&path_arg, false);
                send_response(&mut stream, "200 OK", &response, None);
            }
            ("GET", "/add") | ("GET", "/api/add") => {
                let path_arg = get_path_arg(query);
                if path_arg.is_empty() {
                    dt_warning("Add endpoint called without path parameter");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing path parameter"}"#, None);
                    return;
                }

                match run_yo_command(&["vlc", "--add", &path_arg]) {
                    Ok(_) => {
                        dt_info(&format!("File added to playlist: {}", path_arg));
                        send_response(&mut stream, "200 OK", &format!(r#"{{"status":"ok","action":"add","path":"{}"}}"#, path_arg), None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to add file '{}': {}", path_arg, e));
                        send_response(&mut stream, "500 Internal Server Error", &format!(r#"{{"error":"Failed to add file","path":"{}"}}"#, path_arg), None);
                    }
                }
            }
            ("GET", "/add_folder") | ("GET", "/api/add_folder") => {
                let path_arg = get_path_arg(query);
                if path_arg.is_empty() {
                    dt_warning("Add folder endpoint called without path parameter");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing path parameter"}"#, None);
                    return;
                }
                log(&format!("Adding folder: {}", path_arg));
                match run_yo_command(&["vlc", "--addDir", &path_arg]) {
                    Ok(_) => {
                        dt_info(&format!("‚úÖ Folder added to playlist: {}", path_arg));
                        send_response(&mut stream, "200 OK", &format!(r#"{{"status":"ok","action":"add_folder","path":"{}"}}"#, path_arg), None);
                    }
                    Err(e) => {
                        dt_error(&format!("‚ùå Failed to add folder '{}': {}", path_arg, e));
                        send_response(&mut stream, "500 Internal Server Error", &format!(r#"{{"error":"Failed to add folder","path":"{}"}}"#, path_arg), None);
                    }
                }
            }
            ("GET", "/timers") | ("GET", "/api/timers") => {
                match run_yo_command(&["timer", "--list"]) {
                    Ok(output) => {
                        dt_info("Listing timers");
                        send_response(&mut stream, "200 OK", &output, None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to fetch timers: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", r#"{"error":"Failed to fetch timers"}"#, None);
                    }
                }
            }
            ("GET", "/alarms") | ("GET", "/api/alarms") => {
                match run_yo_command(&["alarm", "--list"]) {
                    Ok(output) => send_response(&mut stream, "200 OK", &output, None),
                    Err(_) => send_response(&mut stream, "500 Internal Server Error", r#"{"error":"Failed to fetch alarms"}"#, None),
                }
            }
            ("GET", "/shopping") | ("GET", "/shopping-list") | ("GET", "/api/shopping") => {
                let response = handle_shopping_list();
                if response.contains("error") {
                    send_response(&mut stream, "500 Internal Server Error", &response, None);
                } else {
                    send_response(&mut stream, "200 OK", &response, None);
                }
            }
            ("GET", "/reminders") | ("GET", "/remmind") | ("GET", "/api/reminders") => {
                let response = handle_reminders();
                if response.contains("error") {
                    send_response(&mut stream, "500 Internal Server Error", &response, None);
                } else {
                    send_response(&mut stream, "200 OK", &response, None);
                }
            }
            ("GET", "/playlist") | ("GET", "/api/playlist") => {
                match run_yo_command(&["vlc", "--list"]) {
                    Ok(output) => send_response(&mut stream, "200 OK", &output, None),
                    Err(_) => send_response(&mut stream, "500 Internal Server Error", r#"{"error":"Failed to fetch playlist"}"#, None),
                }
            }           
            ("GET", "/playlist/remove") | ("GET", "/api/playlist/remove") => {
                let index_str = get_query_arg(query, "index");
                if index_str.is_empty() {
                    dt_warning("Playlist remove called without index");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing index parameter"}"#, None);
                    return;
                }
    
                match run_yo_command(&["vlc", "--list"]) {
                    Ok(playlist_json) => {
                        match serde_json::from_str::<serde_json::Value>(&playlist_json) {
                            Ok(parsed) => {
                                if let Some(playlist_array) = parsed.get("playlist").and_then(|p| p.as_array()) {
                                    let index = index_str.parse::<usize>().unwrap_or(usize::MAX);
                                    if index >= playlist_array.len() {
                                        dt_warning(&format!("Index {} out of bounds (playlist has {} items)", index, playlist_array.len()));
                                        send_response(&mut stream, "400 Bad Request", 
                                            &format!(r#"{{"error":"Index {} out of bounds (playlist has {} items)"}}"#, 
                                            index, playlist_array.len()), None);
                                        return;
                                    }
                        
                                    if let Some(path_value) = playlist_array.get(index) {
                                        if let Some(path) = path_value.as_str() {
                                            match run_yo_command(&["vlc", "--remove", "true", "--add", path]) {
                                                Ok(_) => {
                                                    dt_info(&format!("‚úÖ Removed playlist item {}: {}", index, path));
                                                    send_response(&mut stream, "200 OK", 
                                                        &format!(r#"{{"status":"ok","action":"remove","index":{},"path":"{}"}}"#, index, path), None);
                                                }
                                                Err(e) => {
                                                    dt_error(&format!("‚ùå Failed to remove playlist item {}: {}", index, e));
                                                    send_response(&mut stream, "500 Internal Server Error", 
                                                        &format!(r#"{{"error":"Failed to remove item: {}"}}"#, e), None);
                                                }
                                            }
                                        } else {
                                            dt_error(&format!("Invalid path format at index {}", index));
                                            send_response(&mut stream, "500 Internal Server Error", 
                                                r#"{"error":"Invalid path format in playlist"}"#, None);
                                        }
                                    } else {
                                        dt_warning(&format!("Invalid index: {}", index));
                                        send_response(&mut stream, "400 Bad Request", 
                                            &format!(r#"{{"error":"Invalid index: {}"}}"#, index), None);
                                    }
                                } else {
                                    dt_error("Invalid playlist format");
                                    send_response(&mut stream, "500 Internal Server Error", 
                                        r#"{"error":"Invalid playlist format"}"#, None);
                                }
                            }
                            Err(e) => {
                                dt_error(&format!("Failed to parse playlist JSON: {}", e));
                                send_response(&mut stream, "500 Internal Server Error", 
                                    &format!(r#"{{"error":"Failed to parse playlist: {}"}}"#, e), None);
                            }
                        }    
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to fetch playlist: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"Failed to fetch playlist: {}"}}"#, e), None);
                    }
                }
            }

            ("GET", "/playlist/clear") | ("GET", "/api/playlist/clear") => {
                match run_yo_command(&["vlc", "--clear", "true"]) {
                    Ok(_) => {
                        dt_info("üóëÔ∏è Clearing entire playlist");
                        send_response(&mut stream, "200 OK", 
                            r#"{"status":"ok","action":"clear","message":"Playlist cleared"}"#, None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to clear playlist: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"Failed to clear playlist: {}"}}"#, e), None);
                    }
                }
            }

            ("GET", "/playlist/shuffle") | ("GET", "/api/playlist/shuffle") => {
                match run_yo_command(&["vlc", "--shuffle", "true"]) {
                    Ok(_) => {
                        dt_info("Playlist shuffled");
                        send_response(&mut stream, "200 OK", 
                            r#"{"status":"ok","action":"shuffle","message":"Playlist shuffled"}"#, None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to shuffle playlist: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"Failed to shuffle playlist: {}"}}"#, e), None);
                    }
                }
            }
                     
            ("GET", "/health") | ("GET", "/api/health") => {
                let response = handle_health_check();
                send_response(&mut stream, "200 OK", &response, None);
            }            
            ("GET", "/health/all") | ("GET", "/api/health/all") => {
                let response = handle_health_all();
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            ("GET", "/device/list") | ("GET", "/api/device/list") => {
                let response = handle_device_list();
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            ("GET", path) if path.starts_with("/device/") || path.starts_with("/api/device/") => {
                let rest = if let Some(stripped) = path.strip_prefix("/api/device/") {
                    stripped
                } else if let Some(stripped) = path.strip_prefix("/device/") {
                    stripped
                } else {
                    path
                };
    
                if rest == "list" || rest == "rooms" || rest == "types" {
                    // let existing handlers handle 'em
                } else {
                    dt_info(&format!("Device control: {}", rest));
                    let response = handle_device_rest_control(rest);
                    send_response(&mut stream, "200 OK", &response, None);
                    return;
                }
            }
            
            ("GET", path) if path.starts_with("/scene/") || path.starts_with("/api/scene/") => {
                let scene_name = if let Some(stripped) = path.strip_prefix("/api/scene/") {
                    stripped
                } else if let Some(stripped) = path.strip_prefix("/scene/") {
                    stripped
                } else {
                    path
                };
    
                // ü¶Ü says ‚Æû replace + with spaces
                let decoded_scene_name = scene_name.replace('+', " ");
                dt_info(&format!("Scene activation: {}", decoded_scene_name));
                
                let response = handle_scene_activate(&decoded_scene_name);
                if response.contains("error") {
                    dt_warning(&format!("Scene not found: {}", decoded_scene_name));
                    send_response(&mut stream, "404 Not Found", &response, None);
                } else {
                    dt_info(&format!("Scene activated: {}", decoded_scene_name));
                    send_response(&mut stream, "200 OK", &response, None);
                }
            }
            
            ("GET", "/device/rooms") | ("GET", "/api/device/rooms") => {
                let response = handle_rooms_list();
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            ("GET", "/device/types") | ("GET", "/api/device/types") => {
                let response = handle_types_list();
                send_response(&mut stream, "200 OK", &response, None);
            }
         
            ("GET", "/tts") => {
                let text = urldecode(&get_query_arg(query, "text"));
                if text.is_empty() {
                    dt_warning("TTS endpoint called without text");
                    send_response(&mut stream, "400 Bad Request", 
                        r#"{"error":"Missing text parameter"}"#, None);
                    return;
                }
                dt_info(&format!("TTS request: {}", text));
                
                let output = std::process::Command::new("yo")
                    .args(&["say", "--text", &text, "--web"])
                    .output();
            
                match output {
                    Ok(output) if output.status.success() => {
                        let wav_path = String::from_utf8_lossy(&output.stdout).trim().to_string();
                        dt_info(&format!("TTS generated: {}", wav_path));
            
                        match std::fs::read(&wav_path) {
                            Ok(content) => {
                                let response = format!(
                                    "HTTP/1.1 200 OK\r\n\
                                     Content-Type: audio/wav\r\n\
                                     Content-Length: {}\r\n\
                                     Access-Control-Allow-Origin: *\r\n\
                                     Cache-Control: no-cache\r\n\r\n",
                                    content.len()
                                );
            
                                if let Err(e) = stream.write_all(response.as_bytes()) {
                                    dt_error(&format!("Failed to send headers: {}", e));
                                    return;
                                }
            
                                if let Err(e) = stream.write_all(&content) {
                                    dt_error(&format!("Failed to send audio: {}", e));
                                }
                                
                                if let Err(e) = std::fs::remove_file(&wav_path) {
                                    dt_warning(&format!("Failed to remove TTS file {}: {}", wav_path, e));
                                }
                            }
                            Err(e) => {
                                dt_error(&format!("Failed to read WAV file: {}", e));
                                send_response(&mut stream, "500 Internal Server Error", 
                                    r#"{"error":"Failed to read audio"}"#, None);
                            }
                        }
                    }
                    Ok(output) => {
                        let stderr = String::from_utf8_lossy(&output.stderr);
                        dt_error(&format!("TTS command failed: {}", stderr));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"TTS failed: {}"}}"#, stderr), None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to run TTS command: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"TTS command failed: {}"}}"#, e), None);
                    }
                }
            }
                  
            ("GET", "/do") | ("GET", "/api/do") => {
                let command = get_query_arg(query, "cmd");
                if command.is_empty() {
                    dt_warning("Do endpoint called without command");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing cmd parameter"}"#, None);
                    return;
                }
                
                dt_info(&format!("Executing command: {}", command));
                let natural_language = if command.to_lowercase().starts_with("do ") {
                    command[3..].trim().to_string()
                } else {
                    command.trim().to_string()
                };
    
                if natural_language.is_empty() {
                    dt_warning("Empty command after 'do'");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Empty command after 'do'"}"#, None);
                    return;
                }
    
                match run_yo_command(&["do", "--input", &natural_language]) {
                    Ok(output) => {
                        // ü¶Ü says ‚Æû filter out memory & duckTrace logs
                        let filtered_output: String = output
                            .lines()
                            .filter(|line| !line.contains("MEMORY ADJUSTMENT:"))
                            .filter(|line| !line.contains("[ü¶Üüìú]"))
                            .collect::<Vec<&str>>()
                            .join("\n");        

                        // ü¶Ü says ‚Æû replace "‚Æû" (U+2B9E) with "‚ñ∂" (U+25B6) for iOS
                        let cleaned_output = filtered_output
                            .replace('‚Æû', "‚ñ∂")
                            .replace('"', "\\\"")
                            .replace('\n', "\\n");
            
                        dt_info(&format!("Command executed successfully: {}", natural_language));
                        let response = format!(r#"{{"status":"success","command":"{}","output":"{}"}}"#, 
                            natural_language, cleaned_output.trim());
                        send_response(&mut stream, "200 OK", &response, None);
                    }
                    Err(error) => {
                        let cleaned_error = error.replace('"', "\\\"").replace('\n', "\\n");
                        dt_error(&format!("Command failed '{}': {}", natural_language, cleaned_error));
                        let response = format!(r#"{{"status":"error","command":"{}","error":"{}"}}"#, 
                            natural_language, cleaned_error.trim());
                        send_response(&mut stream, "500 Internal Server Error", &response, None);
                    }
                }
            }
            
            ("POST", "/upload") | ("POST", "/api/upload") => {
                dt_info("File upload request");
                let response = handle_file_upload(&headers, &body);
                if response.contains("error") {
                    dt_error(&format!("Upload failed: {}", response));
                } else {
                    dt_info("File uploaded successfully");
                }
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            _ => {
                send_response(&mut stream, "404 Not Found", &format!(r#"{{"error":"Endpoint not found","path":"{}"}}"#, raw_path), None);
            }
        }
    }
   
    fn main() {
        setup_ducktrace_logging(None, None);
        let log_file = std::env::var("DT_LOG_FILE")
            .unwrap_or_else(|_| "api.log".to_string());
        let log_path = std::env::var("DT_LOG_PATH")
            .unwrap_or_else(|_| "/home/${config.this.user.me.name}/.config/duckTrace/".to_string());
        let log_level = std::env::var("DT_LOG_LEVEL")
            .unwrap_or_else(|_| "INFO".to_string());
    
        dt_info(&format!("üöÄ Starting yo API server"));
        dt_info(&format!("Log file: {}{}", log_path, log_file));
        dt_info(&format!("Log Level: {}", log_level));
            
        let args: Vec<String> = env::args().collect();
        if args.len() != 3 {
            dt_error("Usage: yo api");
            std::process::exit(1);
        }
    
        let host = &args[1];
        let port = &args[2];
        let address = format!("{}:{}", host, port);
    
        // ü¶Ü says ‚Æû port in use?
        if TcpListener::bind(&address).is_err() {
            dt_error(&format!("‚ùå Port {} is already in use", port));
            std::process::exit(1);
        }
    
        let listener = TcpListener::bind(&address).expect("Failed to bind to address");
        log("Available endpoints:");
        log("  GET /timers                     - List timers");
        log("  GET /alarms                     - List alarms");
        log("  GET /shopping                   - List shopping items");
        log("  GET /reminders                  - List reminders");
        log("  GET /health                     - Health check (no auth required)");
        log("  GET /health/all                 - All health checks (no auth required)");
        log("  GET /do?cmd=...                 - Execute natural language commands");
        log("  GET /browse?path=...            - Browse media directory (legacy)");
        log("  GET /browsev2?path=...          - Browse media directory (improved)");
        log("  GET /add?path=...               - Add file to playlist");
        log("  GET /add_folder?path=...        - Add folder to playlist");
        log("  GET /playlist                   - Get current playlist");
        log("  GET /playlist/remove?index=...  - Remove item from playlist");
        log("  GET /playlist/clear             - Clear playlist");
        log("  GET /playlist/shuffle           - Shuffle playlist");
        log("  GET /tts?text=...               - Text to speech");
        log("  GET /device/list                - List all devices");
        log("  GET /device/rooms               - List devices by room");
        log("  GET /device/types               - List devices by type");
        log("  GET /scene/{scene}              - Activate scene (e.g., /scene/dark)");
        log("  GET /device/{device}/{command}/{value} - Control devices");
        log("      Examples:");
        log("      /device/PC/state/on                     - Turn device on");
        log("      /device/PC/state/off                    - Turn device off");
        log("      /device/PC/brightness/200               - Set brightness");
        log("      /device/PC/color/%23FF5733              - Set color (#FF5733)");
        log("      /device/PC/temperature/300              - Set color temperature");
        log("      /device/PC/state/on/brightness/200      - Combined commands");
        log("  POST /upload                     - Upload files");
        log("üîê Authentication:");
        log("  All endpoints except /health and /health/all require password authentication");
        log("  Use: Authorization: Bearer <password> header");
        log("  Or:  X-API-Key: <password> header");
        log("  Or:  ?password=<password> query parameter");
        log("  Password is read from YO_API_PASSWORD_FILE environment variable");
        log("Press Ctrl+C to stop");
    
        for stream in listener.incoming() {
            match stream {
                Ok(stream) => {
                    std::thread::spawn(move || {
                        handle_request(stream);
                    });
                }
                Err(e) => {
                    dt_warning(&format!("üîå Connection failed: {}", e));
                }
            }
        }
    }
  '';
  
in { 
  networking.firewall.allowedTCPPorts = [9815];

  # ü¶Ü says ‚Æû  da script yo
  yo.scripts.api = {
    description = "API endpoints for smart home control, virtual media playlist management, system wide health checks and more.";
    category = "üåê Networking";
    autoStart = builtins.elem config.this.host.hostname [ "homie" ];
    logLevel = "DEBUG";
    parameters = [
      { name = "host"; description = "IP to run server on"; default = "0.0.0.0"; }
      { name = "port"; description = "Port for the service"; default = 9815;  } 
      { name = "dir"; description = "Directory path to build inside"; default = "/home/" + config.this.user.me.name + "/api-rs";  }       
    ];
    helpFooter = '' 
      echo "# üîê Authentication:"
      echo "PASS=\$(cat ${config.house.dashboard.passwordFile} | tr -d '[:space:]')"
      
      echo "# Using Authorization header:"
      echo "curl -H 'Authorization: Bearer \$PASS' http://${mqttHostip}:9815/device/list"
      
      echo "# Using X-API-Key header:"
      echo "curl -H 'X-API-Key: PASS' http://${mqttHostip}:9815/device/list"
      
      echo "# Using query parameter:"
      echo "curl 'http://${mqttHostip}:9815/device/list?password=\$PASS'"
      
      echo "# Media Handling"
      echo "Browse"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/browsev2?path=Movies'"      
      echo "Add file to playlist"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/add?path=/Pool/Movies/movie.mp4'"
      echo "Add entire folder to playlist"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/add_folder?path=/Pool/Movies/Godzilla%20(1998)'"
      echo "Check playlist"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist'"
      echo "Remove item from playlist (0-based index):"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist/remove?index=0'"
      echo "Clear entire playlist:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist/clear'"
      echo "Shuffle playlist:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist/shuffle'"
     
      echo "# Health check (no auth required):"
      echo "curl http://${mqttHostip}:9815/health"
      
      echo "# Text-To-Speech"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/tts?text=Hello%20world"
      
      echo "# Yo Do commands:"
      echo "curl 'http://${mqttHostip}:9815/do?cmd=your%20cmmand%20here&password=\$PASS'"
      
      echo "# Control devices:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/state/on'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/state/off'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/brightness/150'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/color/%23FF5733'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/temperature/300'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/state/on/brightness/200'"
  
      echo "# Activate a scene:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/scene/dark'"

      echo "# List devices:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/list'"
      echo "# List devices by room:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/rooms'"
      echo "# List devices by type:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/types'"
      
      echo "# File upload:"
      echo "curl -X POST -H 'X-API-Key: \$PASS' -F 'file=@/path/to/file' 'http://${mqttHostip}:9815/upload'"
    '';
    code = ''
      ${cmdHelpers} 
      HOST="$host"
      PORT="$port"
      tmp=$(mktemp -d)
      trap "rm -rf '$tmp'" EXIT
      mkdir -p "$tmp/src"

      cp ${api-rs} "$tmp/src/main.rs"
      cp ${cargo-toml} "$tmp/Cargo.toml"
      cp ${devices-json} "$tmp/devices.json"
      cp ${scenes-json} "$tmp/scenes.json" 
      cp ${rooms-json} "$tmp/rooms.json"
      cp ${types-json} "$tmp/types.json"
        
      cd "$tmp"

      dt_info "Build complete!"
      
      ${pkgs.cargo}/bin/cargo generate-lockfile
      ${pkgs.cargo}/bin/cargo build --release    
      dt_info "Build complete!"

      dt_info "Starting yo API server (Rust) on $HOST:$PORT" >&2
      echo "Endpoints:" >&2
      echo "  GET /timers     - List timers" >&2
      echo "  GET /alarms     - List alarms" >&2
      echo "  GET /shopping   - List shopping items" >&2
      echo "  GET /health     - Health check" >&2
      echo "  GET /do?cmd=... - Execute natural language commands" >&2
      echo "Press Ctrl+C to stop" >&2

      # ü¶Ü says ‚Æû check yo.scripts.do if DEBUG mode yo
      if [ "$VERBOSE" -ge 1 ]; then
        while true; do
          # ü¶Ü says ‚Æû keep me alive plx
          DEBUG=1 DT_LOG_FILE_PATH="$DT_LOG_PATH$DT_LOG_FILE" YO_API_PASSWORD_FILE="${config.house.dashboard.passwordFile}" ./target/release/api-rs "$HOST" "$PORT"
          EXIT_CODE=$?
          dt_error "api-rs exited with code $EXIT_CODE, restarting in 3 seconds..."
          sleep 3
       done
      fi
      # ü¶Ü says ‚Æû keep me alive plx
      while true; do
        # ü¶Ü says ‚Æû else run debugless yo
        DT_LOG_FILE_PATH="$DT_LOG_PATH$DT_LOG_FILE" YO_API_PASSWORD_FILE="${config.house.dashboard.passwordFile}" ./target/release/api-rs "$HOST" "$PORT"
        EXIT_CODE=$?
        dt_error "api-rs exited with code $EXIT_CODE, restarting in 3 seconds..."
        sleep 3
      done
    '';

  };

  # ü¶Ü says ‚Æû fancy cat'z...
  environment.systemPackages = [ pkgs.socat pkgs.netcat ];

  # ü¶Ü says ‚Æû Simple authentication using environment variables
  environment.sessionVariables = {
    YO_API_USER = config.this.user.me.name;
    YO_API_PASSWORD_FILE = config.house.dashboard.passwordFile;

  };}
  
                </script>

                <script type="text/plain" class="clean-source">
# dotfiles/bin/network/api.nix ‚Æû https://github.com/quackhack-mcblindy/dotfiles
{
  self,
  lib,
  config,
  pkgs,
  cmdHelpers,
  RustDuckTrace,
  ...
} : let     
  sysHosts = lib.attrNames self.nixosConfigurations; 
  mqttHost = lib.findSingle (host:
      let cfg = self.nixosConfigurations.${host}.config;
      in cfg.services.mosquitto.enable or false
    ) null null sysHosts;    
  mqttHostip = if mqttHost != null
    then self.nixosConfigurations.${mqttHost}.config.this.host.ip or (
      let
        resolved = builtins.readFile (pkgs.runCommand "resolve-host" {} ''
          ${pkgs.dnsutils}/bin/host -t A ${mqttHost} > $out
        '');
      in
        lib.lists.head (lib.strings.splitString " " (lib.lists.elemAt (lib.strings.splitString "\n" resolved) 0))
    )
    else (throw "No Mosquitto host found in configuration");
  mqttAuth = "-u mqtt -P $(cat ${config.sops.secrets.mosquitto.path})";
    
  zigbeeDevices = config.house.zigbee.devices;
  
  normalizedDeviceMap = lib.mapAttrs' (id: device:
    lib.nameValuePair (lib.toLower device.friendly_name) device.friendly_name
  ) zigbeeDevices;

  deviceList = builtins.attrNames normalizedDeviceMap;

  sceneLight = {state, brightness ? 200, hex ? null, temp ? null}:
    let
      colorValue = if hex != null then { inherit hex; } else null;
    in
    {
      inherit state brightness;
    } // (if colorValue != null then { color = colorValue; } else {})
      // (if temp != null then { color_temp = temp; } else {});

  scenes = config.house.zigbee.scenes;

  makeCommand = device: settings:
    let
      json = builtins.toJSON settings;
    in
      ''
      yo mqtt_pub --topic "zigbee2mqtt/${device}/set" --message '${json}'
      '';
      
  sceneCommands = lib.mapAttrs
    (sceneName: sceneDevices:
      lib.mapAttrs (device: settings: makeCommand device settings) sceneDevices
    ) scenes;  

  byRoom = lib.foldlAttrs (acc: id: dev:
    lib.recursiveUpdate acc {
      ${dev.room} = (acc.${dev.room} or []) ++ [ id ];
    }) {} zigbeeDevices;

  byType = lib.foldlAttrs (acc: id: dev:
    lib.recursiveUpdate acc {
      ${dev.type} = (acc.${dev.type} or []) ++ [ id ];
    }) {} zigbeeDevices;

  groupConfig = lib.mapAttrs' (room: ids: {
    name = room;
    value = {
      friendly_name = room;
      devices = map (id: 
        let dev = zigbeeDevices.${id};
        in "${id}/${toString dev.endpoint}"
      ) ids;
    };
  }) byRoom;

  tvDevicesJson = pkgs.writeText "tv-devices.json" (builtins.toJSON config.house.tv);

  deviceConfig = lib.mapAttrs (id: dev: {
    friendly_name = dev.friendly_name;
  }) zigbeeDevices;

  ieeeToFriendly = lib.mapAttrs (ieee: dev: dev.friendly_name) zigbeeDevices;
  mappingJSON = builtins.toJSON ieeeToFriendly;
  mappingFile = pkgs.writeText "ieee-to-friendly.json" mappingJSON;

  deviceMeta = builtins.toJSON (
    lib.listToAttrs (
      lib.filter (attr: attr.name != null) (
        lib.mapAttrsToList (_: dev: {
          name = dev.friendly_name;
          value = {
            room = dev.room;
            type = dev.type;
            id = dev.friendly_name;
            endpoint = dev.endpoint;
          };
        }) zigbeeDevices
      )
    )
  );

  automationsJSON = builtins.toJSON config.house.zigbee.automations;
  automationsFile = pkgs.writeText "automations.json" automationsJSON;

  darkTimeEnabled = if config.house.zigbee.darkTime.enable then "1" else "0";

  devices-json = pkgs.writeText "devices.json" deviceMeta;

  scenes-json = pkgs.writeText "scenes.json" (builtins.toJSON sceneCommands);
  rooms-json = pkgs.writeText "rooms.json" (builtins.toJSON (
    lib.mapAttrs (room: devices: {
      inherit room;
      devices = map (id: zigbeeDevices.${id}.friendly_name) devices;
    }) byRoom
  ));
  types-json = pkgs.writeText "types.json" (builtins.toJSON (
    lib.mapAttrs (type: devices: {
      inherit type;
      devices = map (id: zigbeeDevices.${id}.friendly_name) devices;
    }) byType
  ));

  cargo-toml = pkgs.writeText "Cargo.toml" ''
    [package]
    name = "api-rs"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    serde_json = "1.0"
    chrono = { version = "0.4", features = ["serde"] }
    multipart = "0.18"
    colored = "2.1" 
  ''; 

  api-rs = pkgs.writeText "api.rs" ''
    ${RustDuckTrace}
    
    use std::io::{BufRead, BufReader, Read};
    use std::net::{TcpListener, TcpStream};
    use std::process::Command;
    use std::collections::HashMap;
    use std::fs::{self, create_dir_all};
    use serde_json::json;
    

    fn log(message: &str) {
        eprintln!("[API] {}", message);
    }

    fn check_password_auth(headers: &HashMap<String, String>, query: &str) -> bool {
        let password_file_path = std::env::var("YO_API_PASSWORD_FILE")
            .unwrap_or_else(|_| "${config.house.dashboard.passwordFile}".to_string());
        
        let expected_password = match std::fs::read_to_string(&password_file_path) {
            Ok(content) => content.trim().to_string(),
            Err(_) => {
                log(&format!("Warning: Could not read password file: {}", password_file_path));
                return false;
            }
        };
        
        if let Some(auth_header) = headers.get("authorization") {
            if auth_header.starts_with("Bearer ") {
                let provided_password = auth_header[7..].trim();
                return provided_password == expected_password;
            } else if auth_header.starts_with("Password ") {
                let provided_password = auth_header[9..].trim();
                return provided_password == expected_password;
            }
        }
        
        let query_password = get_query_arg(query, "password");
        if !query_password.is_empty() && query_password == expected_password {
            return true;
        }
        
        if let Some(api_key) = headers.get("x-api-key") {
            return api_key.trim() == expected_password;
        }       
        false
    }
        
    fn urldecode(s: &str) -> String {
        let mut result = Vec::new();
        let bytes = s.bytes().collect::<Vec<_>>();
        let mut i = 0;
    
        while i < bytes.len() {
            match bytes[i] {
                b'%' if i + 2 < bytes.len() => {
                    if let (Some(high), Some(low)) = (from_hex(bytes[i + 1]), from_hex(bytes[i + 2])) {
                        let byte = (high << 4) | low;
                        result.push(byte);
                        i += 3;
                        continue;
                    }
                }
                b'+' => {
                    result.push(b' ');
                }
                _ => {
                    result.push(bytes[i]);
                }
            }
            i += 1;
        }
    
        String::from_utf8(result).unwrap_or_else(|_| s.to_string())
    }
    
    fn from_hex(byte: u8) -> Option<u8> {
        match byte {
            b'0'..=b'9' => Some(byte - b'0'),
            b'a'..=b'f' => Some(byte - b'a' + 10),
            b'A'..=b'F' => Some(byte - b'A' + 10),
            _ => None,
        }
    }
    
    fn send_response(stream: &mut TcpStream, status: &str, body: &str, content_type: Option<&str>) {
        let content_type = content_type.unwrap_or("application/json");
        let response = format!(
            "HTTP/1.1 {}\r\n\
             Content-Type: {}\r\n\
             Access-Control-Allow-Origin: *\r\n\
             Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n\
             Access-Control-Allow-Headers: Authorization, Content-Type, X-API-Key\r\n\
             Content-Length: {}\r\n\r\n{}",
            status,
            content_type,
            body.len(),
            body
        );
        if let Err(e) = stream.write_all(response.as_bytes()) {
            dt_warning(&format!("Failed to send response: {}", e));
        }
    }
    
    fn get_query_arg(query: &str, arg_name: &str) -> String {
        let parts: Vec<&str> = query.split('&').collect();
        for part in parts {
            if part.starts_with(&format!("{}=", arg_name)) {
                let encoded = &part[arg_name.len() + 1..];
                return urldecode(encoded);
            }
        }
        String::new()
    }
    
    fn get_path_arg(query: &str) -> String {
        let parts: Vec<&str> = query.split('&').collect();
        for part in parts {
            if part.starts_with("path=") {
                let encoded = &part[5..];
                return urldecode(encoded);
            }
        }
        String::new()
    }
    
    fn handle_browse(path_arg: &str, use_v2: bool) -> String {
        let media_root = "/Pool";
        let full_path = format!("{}/{}", media_root, path_arg);
        
        if !full_path.starts_with(media_root) {
            dt_warning(&format!("Access forbidden for path: {}", path_arg));
            return r#"{"error":"Access forbidden"}"#.to_string();
        }
    
        let path_std = std::path::Path::new(&full_path);
        if !path_std.exists() || !path_std.is_dir() {
            return format!(r#"{{"error":"Directory not found: {}"}}"#, path_arg);
        }
    
        let mut directories = Vec::new();
        let mut files = Vec::new();
    
        if use_v2 {
            let output = Command::new("find")
                .arg(&full_path)
                .arg("-maxdepth")
                .arg("1")
                .arg("-mindepth")
                .arg("1")
                .output();
            
            match output {
                Ok(output) if output.status.success() => {
                    let output_str = String::from_utf8_lossy(&output.stdout);
                    for line in output_str.lines() {
                        if line.is_empty() { continue; }
                        let item_path = std::path::Path::new(line);
                        if let Some(name) = item_path.file_name().and_then(|n| n.to_str()) {
                            if item_path.is_dir() {
                                directories.push(name.to_string());
                            } else {
                                files.push(name.to_string());
                            }
                        }
                    }
                }
                _ => return r#"{"error":"Failed to list directory"}"#.to_string(),
            }
        } else {
            let output = Command::new("ls")
                .arg("-1")
                .arg(&full_path)
                .output();
            
            match output {
                Ok(output) if output.status.success() => {
                    let output_str = String::from_utf8_lossy(&output.stdout);
                    for item in output_str.lines() {
                        if item.is_empty() { continue; }
                        let item_path = path_std.join(item);
                        if item_path.is_dir() {
                            directories.push(item.to_string());
                        } else {
                            files.push(item.to_string());
                        }
                    }
                }
                _ => return r#"{"error":"Failed to list directory"}"#.to_string(),
            }
        }
    
        directories.sort();
        files.sort();
    
        let dirs_json = serde_json::to_string(&directories).unwrap_or_else(|_| "[]".to_string());
        let files_json = serde_json::to_string(&files).unwrap_or_else(|_| "[]".to_string());
    
        if use_v2 {
            let real_full_path = path_std.canonicalize().unwrap_or_else(|_| path_std.to_path_buf());
            format!(
                r#"{{"path":"{}","full_path":"{}","directories":{},"files":{}}}"#,
                path_arg,
                real_full_path.display(),
                dirs_json,
                files_json
            )
        } else {
            format!(
                r#"{{"path":"{}","directories":{},"files":{}}}"#,
                path_arg,
                dirs_json,
                files_json
            )
        }
    }
    
    fn run_yo_command(args: &[&str]) -> Result<String, String> {
        let output = Command::new("yo")
            .args(args)
            .output()
            .map_err(|e| format!("Failed to execute yo command: {}", e))?;
        
        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(String::from_utf8_lossy(&output.stderr).to_string())
        }
    }

    fn handle_file_upload(headers: &HashMap<String, String>, body: &[u8]) -> String {
        let uploads_dir = "/var/lib/zigduck/uploads";
        if let Err(e) = create_dir_all(uploads_dir) {
            return format!(r#"{{"error":"Failed to create uploads directory: {}"}}"#, e);
        }
    
        let content_type = headers.get("content-type").unwrap_or(&String::new()).clone();
        
        if !content_type.contains("multipart/form-data") {
            return r#"{"error":"Only multipart/form-data uploads are supported"}"#.to_string();
        }
        
        let boundary = if let Some(idx) = content_type.find("boundary=") {
            content_type[idx + "boundary=".len()..].trim().to_string()
        } else {
            return r#"{"error":"No boundary in Content-Type"}"#.to_string();
        };
        
        dt_debug(&format!("Boundary: {}", boundary));
        
        let body_str = match String::from_utf8(body.to_vec()) {
            Ok(s) => s,
            Err(_) => return r#"{"error":"Body is not valid UTF-8"}"#.to_string(),
        };
        
        let boundary_marker = format!("--{}", boundary);
        let parts: Vec<&str> = body_str.split(&boundary_marker).collect();
        
        dt_debug(&format!("Found {} parts", parts.len()));
        
        for (i, part) in parts.iter().enumerate().skip(1) {
            if i == parts.len() - 1 && part.trim().ends_with("--") {
                continue;
            }
            
            let part = part.trim();
            if part.is_empty() {
                continue;
            }
            
            log(&format!("Part {}: {} chars", i, part.len()));
            
            if let Some(idx) = part.find("\r\n\r\n") {
                let headers_part = &part[..idx];
                let content_start = idx + 4;
                let content = &part[content_start..];
                
                let mut filename = None;
                for line in headers_part.split("\r\n") {
                    if line.to_lowercase().contains("filename=") {
                        if let Some(start_idx) = line.find("filename=\"") {
                            let start = start_idx + "filename=\"".len();
                            if let Some(end_idx) = line[start..].find('\"') {
                                filename = Some(line[start..start + end_idx].to_string());
                                break;
                            }
                        }
                    }
                }
                
                if let Some(original_filename) = filename {
                    fn get_unique_filename(dir: &str, base: &str) -> Result<String, String> {
                        use std::path::Path;               
                        const MAX_ATTEMPTS: usize = 1000;
                        
                        let path = Path::new(base);
                        let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or("file");
                        let ext = path.extension().and_then(|s| s.to_str()).unwrap_or("");
                        
                        let mut candidate = base.to_string();
                        let mut full_path = Path::new(dir).join(&candidate);
                        
                        if !full_path.exists() {
                            dt_debug(&format!("Base filename available: {}", candidate));
                            return Ok(candidate);
                        }
                        
                        dt_info(&format!("Base filename exists: {}, generating unique name", candidate));
                        
                        for counter in 1..=MAX_ATTEMPTS {
                            candidate = if ext.is_empty() {
                                format!("{}({})", stem, counter)
                            } else {
                                format!("{}({}).{}", stem, counter, ext)
                            };
                            
                            full_path = Path::new(dir).join(&candidate);
                            if !full_path.exists() {
                                log(&format!("Found unique filename: {}", candidate));
                                return Ok(candidate);
                            }
                        }               
                        Err(format!("Could not find unique filename after {} attempts", MAX_ATTEMPTS))
                    }
                    
                    let sanitized = sanitize_filename(&original_filename);
                    log(&format!("Sanitized filename: {}", sanitized));
                    
                    match get_unique_filename(uploads_dir, &sanitized) {
                        Ok(unique_name) => {
                            let destination = format!("{}/{}", uploads_dir, unique_name);
                            let clean_content = content.trim_end_matches("\r\n");
                            
                            log(&format!("Writing {} bytes to {}", clean_content.len(), destination));
                            
                            match std::fs::write(&destination, clean_content) {
                                Ok(_) => {
                                    let file_size = clean_content.len();
                                    
                                    let response = json!({
                                        "status": "success",
                                        "message": "File uploaded successfully",
                                        "files": [{
                                            "filename": unique_name,
                                            "original_filename": original_filename,
                                            "size": file_size,
                                            "path": destination
                                        }]
                                    }).to_string();
                                    
                                    dt_info(&format!("Upload successful: {}", response));
                                    return response;
                                }
                                Err(e) => {
                                    let error_msg = format!(r#"{{"error":"Failed to write file: {}"}}"#, e);
                                    log(&format!("Write error: {}", error_msg));
                                    return error_msg;
                                }
                            }
                        }
                        Err(e) => {
                            let error_msg = format!(r#"{{"error":"{}"}}"#, e);
                            log(&format!("Unique filename error: {}", error_msg));
                            return error_msg;
                        }
                    }
                }
            }
        }   
        r#"{"error":"No file found in upload"}"#.to_string()
    }

    fn sanitize_filename(filename: &str) -> String {
        let mut sanitized = String::new();
        for c in filename.chars() {
            if c.is_alphanumeric() || c == '.' || c == '-' || c == '_' {
                sanitized.push(c);
            } else if c == ' ' {
                sanitized.push('_');
            }
        }    

        if sanitized.is_empty() {
            format!("file_{}.bin", chrono::Local::now().format("%Y%m%d_%H%M%S"))
        } else {
            sanitized
        }
    }
      
    fn handle_shopping_list() -> String {
        match run_yo_command(&["shop-list", "--list"]) {
            Ok(output) => {
                let items: Vec<&str> = output.lines().collect();
                match serde_json::to_string(&items) {
                    Ok(json_items) => format!(r#"{{"items":{}}}"#, json_items),
                    Err(_) => r#"{"error":"Failed to format shopping list"}"#.to_string(),
                }
            }
            Err(_) => r#"{"error":"Failed to fetch shopping list"}"#.to_string(),
        }
    }
    
    fn handle_reminders() -> String {
        match run_yo_command(&["reminder", "--list"]) {
            Ok(output) => {
                let items: Vec<&str> = output.lines().collect();
                match serde_json::to_string(&items) {
                    Ok(json_items) => format!(r#"{{"items":{}}}"#, json_items),
                    Err(_) => r#"{"error":"Failed to format reminders"}"#.to_string(),
                }
            }
            Err(_) => r#"{"error":"Failed to fetch reminders"}"#.to_string(),
        }
    }
    
    fn handle_device_list() -> String {
        match fs::read_to_string("devices.json") {
            Ok(content) => content,
            Err(_) => r#"{"error":"Devices file not found"}"#.to_string(),
        }
    }
            
    fn handle_device_rest_control(path: &str) -> String {
        dt_info(&format!("Device control request: {}", path));    
        let segments: Vec<&str> = path.split('/').collect();
        
        if segments.is_empty() {
            dt_warning("Device control called without device name");
            return r#"{"error":"Missing device name"}"#.to_string();
        }
        
        let device_name = urldecode(segments[0]);
        dt_info(&format!("Controlling device: {}", device_name));
        
        let mut commands = Vec::new();
        let mut i = 1;
        
        while i < segments.len() {
            if i + 1 < segments.len() {
                let action = segments[i];
                let value = urldecode(segments[i + 1]);
                commands.push((action, value));
                i += 2;
            } else {
                return r#"{"error":"Malformed command path"}"#.to_string();
            }
        }
        
        if commands.is_empty() {
            return r#"{"error":"No commands specified"}"#.to_string();
        }
        
        handle_device_combined_control(&device_name, &commands)
    }
    
    fn handle_device_combined_control(device_name: &str, commands: &[(&str, String)]) -> String {
        dt_info(&format!("Device '{}' commands: {:?}", device_name, commands)); 
        let devices_json = fs::read_to_string("devices.json").unwrap_or_else(|_| "{}".to_string());
        let devices: HashMap<String, serde_json::Value> = serde_json::from_str(&devices_json).unwrap_or_default();
    
        let mut found_device = None;
        for (dev_name, _) in &devices {
            if dev_name.to_lowercase() == device_name.to_lowercase() {
                found_device = Some(dev_name);
                break;
            }
        }
    
        match found_device {
            Some(actual_name) => {
                let mut message = HashMap::new();
                
                for (action, value) in commands {
                    match *action {
                        "state" => {
                            match value.to_lowercase().as_str() {
                                "on" => {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                                "off" => {
                                    message.insert("state".to_string(), "OFF".to_string());
                                }
                                _ => return format!(r#"{{"error":"Invalid state value: {}"}}"#, value),
                            }
                        }
                        "brightness" => {
                            if let Ok(brightness) = value.parse::<u16>() {
                                message.insert("brightness".to_string(), brightness.to_string());

                                if !message.contains_key("state") {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                            } else {
                                return format!(r#"{{"error":"Invalid brightness value: {}"}}"#, value);
                            }
                        }
                        "color" | "colour" => {
                            let hex_value = if value.starts_with('#') { value.clone() } else { format!("#{}", value) };
                            if hex_value.len() == 7 {
                                let color_map = HashMap::from([("hex".to_string(), hex_value)]);
                                message.insert("color".to_string(), serde_json::to_string(&color_map).unwrap());

                                if !message.contains_key("state") {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                            } else {
                                return format!(r#"{{"error":"Invalid color format, use #RRGGBB or RRGGBB"}}"#);
                            }
                        }
                        "temperature" | "temp" | "color_temp" => {
                            if let Ok(temp) = value.parse::<u16>() {
                                message.insert("color_temp".to_string(), temp.to_string());
                                if !message.contains_key("state") {
                                    message.insert("state".to_string(), "ON".to_string());
                                }
                            } else {
                                return format!(r#"{{"error":"Invalid temperature value: {}"}}"#, value);
                            }
                        }
                        _ => return format!(r#"{{"error":"Unknown action: {}"}}"#, action),
                    }
                }
                
                let message_json = serde_json::to_string(&message).unwrap_or_else(|_| "{}".to_string());
                let topic = format!("zigbee2mqtt/{}/set", actual_name);
                
                match run_yo_command(&["mqtt_pub", "--topic", &topic, "--message", &message_json]) {
                    Ok(_) => {
                        let command_list: Vec<String> = commands.iter()
                            .map(|(a, v)| format!("{}:{}", a, v))
                            .collect();
                        format!(r#"{{"status":"ok","device":"{}","commands":{}}}"#, 
                            actual_name, serde_json::to_string(&command_list).unwrap())
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to control device '{}': {}", actual_name, e));
                        format!(r#"{{"error":"Failed to control device: {}"}}"#, e)
                    }
                }
            }
            None => format!(r#"{{"error":"Device not found: {}"}}"#, device_name),
        }
    }
        
    fn handle_scene_activate(scene_name: &str) -> String {
        if scene_name.is_empty() {
            dt_warning("Scene activation called with empty scene name");
            return r#"{"error":"Missing scene name"}"#.to_string();
        }

        dt_info(&format!("Activating scene: {}", scene_name));

        let scenes_content = match fs::read_to_string("scenes.json") {
            Ok(content) => content,
            Err(_) => {
                dt_error("Scenes file not found");
                return r#"{"error":"Scenes file not found"}"#.to_string();
            }
        };

        let scenes_map: HashMap<String, serde_json::Value> = 
            serde_json::from_str(&scenes_content).unwrap_or_default();

        let mut scene_lowercase_map = HashMap::new();
        for (scene_key, _) in &scenes_map {
            scene_lowercase_map.insert(scene_key.to_lowercase(), scene_key.clone());
        }

        let normalized_scene_name = scene_name.to_lowercase();
    
        match scene_lowercase_map.get(&normalized_scene_name) {
            Some(actual_scene_name) => {
                match run_yo_command(&["house", "--scene", actual_scene_name]) {
                    Ok(_) => format!(r#"{{"status":"ok","scene":"{}"}}"#, actual_scene_name),
                    Err(e) => format!(r#"{{"error":"Failed to activate scene: {}"}}"#, e),
                }
            }
            None => format!(r#"{{"error":"Scene not found: {}"}}"#, scene_name),
        }
    }
    
    fn handle_rooms_list() -> String {
        match fs::read_to_string("rooms.json") {
            Ok(content) => content,
            Err(_) => r#"{"error":"Rooms data not available"}"#.to_string(),
        }
    }
    
    fn handle_types_list() -> String {
        match fs::read_to_string("types.json") {
            Ok(content) => content,
            Err(_) => r#"{"error":"Types data not available"}"#.to_string(),
        }
    }
    
    fn handle_health_check() -> String {
        match Command::new("health").output() {
            Ok(output) if output.status.success() => {
                let health_output = String::from_utf8_lossy(&output.stdout);
                health_output.to_string()
            }
            Ok(output) => {
                let error_msg = String::from_utf8_lossy(&output.stderr);
                let timestamp = chrono::Local::now().format("%Y-%m-%dT%H:%M:%S%z").to_string();
                format!(
                    r#"{{"status":"degraded","service":"yo-api","timestamp":"{}","error":"Health check failed: {}"}}"#,
                    timestamp, error_msg
                )
            }
            Err(e) => {
                let timestamp = chrono::Local::now().format("%Y-%m-%dT%H:%M:%S%z").to_string();
                format!(
                    r#"{{"status":"degraded","service":"yo-api","timestamp":"{}","error":"Health command failed: {}"}}"#,
                    timestamp, e
                )
            }
        }
    }

    fn handle_health_all() -> String {
        let health_dir = "/var/lib/zigduck/health";
        let mut health_data = std::collections::HashMap::new();

        if let Ok(entries) = std::fs::read_dir(health_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("json") {
                    if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                        if let Ok(content) = std::fs::read_to_string(&path) {
                            if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                                health_data.insert(file_stem.to_string(), json);
                            }
                        }
                    }
                }
            }
        }

        match serde_json::to_string(&health_data) {
            Ok(json) => json,
            Err(_) => r#"{"error":"Failed to serialize health data"}"#.to_string(),
        }
    }
    
    fn handle_request(mut stream: TcpStream) {
        let peer_addr = match stream.peer_addr() {
            Ok(addr) => addr.to_string(),
            Err(_) => "unknown".to_string(),
        };

        let mut reader = BufReader::new(&stream);
        let mut request_line = String::new();
        
        if reader.read_line(&mut request_line).is_err() || request_line.is_empty() {
            log("No data on stdin; exiting");
            return;
        }
        dt_info(&format!("[{}] Request: {}", peer_addr, request_line.trim()));
        
        log(&format!("Request: {}", request_line.trim()));
    
        let parts: Vec<&str> = request_line.split_whitespace().collect();
        if parts.len() < 2 {
            return;
        }
    
        let method = parts[0];
        let raw_path = parts[1];
    
        let mut content_length = 0;
        let mut headers = HashMap::new();
        let mut header_line = String::new();
        loop {
            header_line.clear();
            if reader.read_line(&mut header_line).is_err() || header_line.is_empty() {
                break;
            }
            if header_line == "\r\n" || header_line == "\n" {
                break;
            }
            
            if let Some((key, value)) = header_line.split_once(':') {
                let key_lower = key.trim().to_lowercase();
                let value_trimmed = value.trim().to_string();
                
                if key_lower == "content-length" {
                    content_length = value_trimmed.parse().unwrap_or(0);
                }
                
                headers.insert(key_lower, value_trimmed);
            }
        }
    
        let mut body = Vec::new();
        if content_length > 0 {
            let mut body_buf = vec![0; content_length];
            if let Ok(()) = reader.read_exact(&mut body_buf) {
                body = body_buf;
                log(&format!("Body size: {} bytes", body.len()));
            }
        }
    
        let (path_no_query, query) = match raw_path.split_once('?') {
            Some((path, query)) => (path, query),
            None => (raw_path, ""),
        };
    
        if path_no_query != "/health" && path_no_query != "/health/all" && !check_password_auth(&headers, query) {
            send_response(&mut stream, "401 Unauthorized", 
                r#"{"error":"Authentication required","message":"Valid password required in Authorization: Bearer <password> header, X-API-Key header, or ?password= query parameter"}"#, 
                None);
            return;
        }
    
        match (method, path_no_query) {
            ("OPTIONS", _) => {
                dt_debug("CORS preflight request");
                send_response(&mut stream, "200 OK", "", None);
                return;
            }
        
            ("GET", "/") => {
                dt_info("Root endpoint requested");
                send_response(&mut stream, "200 OK", 
                    r#"{"service":"yo-api","endpoints":["/timers","/alarms","/shopping","/reminders","/health","/browse","/browsev2","/add","/add_folder","/playlist","/playlist/remove","/playlist/clear","/playlist/shuffle","/do","/device/list","/device/{device}/...","/scene/{scene}","/device/rooms","/device/types","/upload","/tts"]}"#,
                    None);
            }
            ("GET", "/browsev2") | ("GET", "/api/browsev2") => {
                let path_arg = get_path_arg(query);
                let response = handle_browse(&path_arg, true);
                send_response(&mut stream, "200 OK", &response, None);
            }
            ("GET", "/browse") | ("GET", "/api/browse") => {
                let path_arg = get_path_arg(query);
                let response = handle_browse(&path_arg, false);
                send_response(&mut stream, "200 OK", &response, None);
            }
            ("GET", "/add") | ("GET", "/api/add") => {
                let path_arg = get_path_arg(query);
                if path_arg.is_empty() {
                    dt_warning("Add endpoint called without path parameter");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing path parameter"}"#, None);
                    return;
                }

                match run_yo_command(&["vlc", "--add", &path_arg]) {
                    Ok(_) => {
                        dt_info(&format!("File added to playlist: {}", path_arg));
                        send_response(&mut stream, "200 OK", &format!(r#"{{"status":"ok","action":"add","path":"{}"}}"#, path_arg), None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to add file '{}': {}", path_arg, e));
                        send_response(&mut stream, "500 Internal Server Error", &format!(r#"{{"error":"Failed to add file","path":"{}"}}"#, path_arg), None);
                    }
                }
            }
            ("GET", "/add_folder") | ("GET", "/api/add_folder") => {
                let path_arg = get_path_arg(query);
                if path_arg.is_empty() {
                    dt_warning("Add folder endpoint called without path parameter");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing path parameter"}"#, None);
                    return;
                }
                log(&format!("Adding folder: {}", path_arg));
                match run_yo_command(&["vlc", "--addDir", &path_arg]) {
                    Ok(_) => {
                        dt_info(&format!("‚úÖ Folder added to playlist: {}", path_arg));
                        send_response(&mut stream, "200 OK", &format!(r#"{{"status":"ok","action":"add_folder","path":"{}"}}"#, path_arg), None);
                    }
                    Err(e) => {
                        dt_error(&format!("‚ùå Failed to add folder '{}': {}", path_arg, e));
                        send_response(&mut stream, "500 Internal Server Error", &format!(r#"{{"error":"Failed to add folder","path":"{}"}}"#, path_arg), None);
                    }
                }
            }
            ("GET", "/timers") | ("GET", "/api/timers") => {
                match run_yo_command(&["timer", "--list"]) {
                    Ok(output) => {
                        dt_info("Listing timers");
                        send_response(&mut stream, "200 OK", &output, None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to fetch timers: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", r#"{"error":"Failed to fetch timers"}"#, None);
                    }
                }
            }
            ("GET", "/alarms") | ("GET", "/api/alarms") => {
                match run_yo_command(&["alarm", "--list"]) {
                    Ok(output) => send_response(&mut stream, "200 OK", &output, None),
                    Err(_) => send_response(&mut stream, "500 Internal Server Error", r#"{"error":"Failed to fetch alarms"}"#, None),
                }
            }
            ("GET", "/shopping") | ("GET", "/shopping-list") | ("GET", "/api/shopping") => {
                let response = handle_shopping_list();
                if response.contains("error") {
                    send_response(&mut stream, "500 Internal Server Error", &response, None);
                } else {
                    send_response(&mut stream, "200 OK", &response, None);
                }
            }
            ("GET", "/reminders") | ("GET", "/remmind") | ("GET", "/api/reminders") => {
                let response = handle_reminders();
                if response.contains("error") {
                    send_response(&mut stream, "500 Internal Server Error", &response, None);
                } else {
                    send_response(&mut stream, "200 OK", &response, None);
                }
            }
            ("GET", "/playlist") | ("GET", "/api/playlist") => {
                match run_yo_command(&["vlc", "--list"]) {
                    Ok(output) => send_response(&mut stream, "200 OK", &output, None),
                    Err(_) => send_response(&mut stream, "500 Internal Server Error", r#"{"error":"Failed to fetch playlist"}"#, None),
                }
            }           
            ("GET", "/playlist/remove") | ("GET", "/api/playlist/remove") => {
                let index_str = get_query_arg(query, "index");
                if index_str.is_empty() {
                    dt_warning("Playlist remove called without index");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing index parameter"}"#, None);
                    return;
                }
    
                match run_yo_command(&["vlc", "--list"]) {
                    Ok(playlist_json) => {
                        match serde_json::from_str::<serde_json::Value>(&playlist_json) {
                            Ok(parsed) => {
                                if let Some(playlist_array) = parsed.get("playlist").and_then(|p| p.as_array()) {
                                    let index = index_str.parse::<usize>().unwrap_or(usize::MAX);
                                    if index >= playlist_array.len() {
                                        dt_warning(&format!("Index {} out of bounds (playlist has {} items)", index, playlist_array.len()));
                                        send_response(&mut stream, "400 Bad Request", 
                                            &format!(r#"{{"error":"Index {} out of bounds (playlist has {} items)"}}"#, 
                                            index, playlist_array.len()), None);
                                        return;
                                    }
                        
                                    if let Some(path_value) = playlist_array.get(index) {
                                        if let Some(path) = path_value.as_str() {
                                            match run_yo_command(&["vlc", "--remove", "true", "--add", path]) {
                                                Ok(_) => {
                                                    dt_info(&format!("‚úÖ Removed playlist item {}: {}", index, path));
                                                    send_response(&mut stream, "200 OK", 
                                                        &format!(r#"{{"status":"ok","action":"remove","index":{},"path":"{}"}}"#, index, path), None);
                                                }
                                                Err(e) => {
                                                    dt_error(&format!("‚ùå Failed to remove playlist item {}: {}", index, e));
                                                    send_response(&mut stream, "500 Internal Server Error", 
                                                        &format!(r#"{{"error":"Failed to remove item: {}"}}"#, e), None);
                                                }
                                            }
                                        } else {
                                            dt_error(&format!("Invalid path format at index {}", index));
                                            send_response(&mut stream, "500 Internal Server Error", 
                                                r#"{"error":"Invalid path format in playlist"}"#, None);
                                        }
                                    } else {
                                        dt_warning(&format!("Invalid index: {}", index));
                                        send_response(&mut stream, "400 Bad Request", 
                                            &format!(r#"{{"error":"Invalid index: {}"}}"#, index), None);
                                    }
                                } else {
                                    dt_error("Invalid playlist format");
                                    send_response(&mut stream, "500 Internal Server Error", 
                                        r#"{"error":"Invalid playlist format"}"#, None);
                                }
                            }
                            Err(e) => {
                                dt_error(&format!("Failed to parse playlist JSON: {}", e));
                                send_response(&mut stream, "500 Internal Server Error", 
                                    &format!(r#"{{"error":"Failed to parse playlist: {}"}}"#, e), None);
                            }
                        }    
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to fetch playlist: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"Failed to fetch playlist: {}"}}"#, e), None);
                    }
                }
            }

            ("GET", "/playlist/clear") | ("GET", "/api/playlist/clear") => {
                match run_yo_command(&["vlc", "--clear", "true"]) {
                    Ok(_) => {
                        dt_info("üóëÔ∏è Clearing entire playlist");
                        send_response(&mut stream, "200 OK", 
                            r#"{"status":"ok","action":"clear","message":"Playlist cleared"}"#, None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to clear playlist: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"Failed to clear playlist: {}"}}"#, e), None);
                    }
                }
            }

            ("GET", "/playlist/shuffle") | ("GET", "/api/playlist/shuffle") => {
                match run_yo_command(&["vlc", "--shuffle", "true"]) {
                    Ok(_) => {
                        dt_info("Playlist shuffled");
                        send_response(&mut stream, "200 OK", 
                            r#"{"status":"ok","action":"shuffle","message":"Playlist shuffled"}"#, None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to shuffle playlist: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"Failed to shuffle playlist: {}"}}"#, e), None);
                    }
                }
            }
                     
            ("GET", "/health") | ("GET", "/api/health") => {
                let response = handle_health_check();
                send_response(&mut stream, "200 OK", &response, None);
            }            
            ("GET", "/health/all") | ("GET", "/api/health/all") => {
                let response = handle_health_all();
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            ("GET", "/device/list") | ("GET", "/api/device/list") => {
                let response = handle_device_list();
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            ("GET", path) if path.starts_with("/device/") || path.starts_with("/api/device/") => {
                let rest = if let Some(stripped) = path.strip_prefix("/api/device/") {
                    stripped
                } else if let Some(stripped) = path.strip_prefix("/device/") {
                    stripped
                } else {
                    path
                };
    
                if rest == "list" || rest == "rooms" || rest == "types" {
                    // let existing handlers handle 'em
                } else {
                    dt_info(&format!("Device control: {}", rest));
                    let response = handle_device_rest_control(rest);
                    send_response(&mut stream, "200 OK", &response, None);
                    return;
                }
            }
            
            ("GET", path) if path.starts_with("/scene/") || path.starts_with("/api/scene/") => {
                let scene_name = if let Some(stripped) = path.strip_prefix("/api/scene/") {
                    stripped
                } else if let Some(stripped) = path.strip_prefix("/scene/") {
                    stripped
                } else {
                    path
                };
    
                let decoded_scene_name = scene_name.replace('+', " ");
                dt_info(&format!("Scene activation: {}", decoded_scene_name));
                
                let response = handle_scene_activate(&decoded_scene_name);
                if response.contains("error") {
                    dt_warning(&format!("Scene not found: {}", decoded_scene_name));
                    send_response(&mut stream, "404 Not Found", &response, None);
                } else {
                    dt_info(&format!("Scene activated: {}", decoded_scene_name));
                    send_response(&mut stream, "200 OK", &response, None);
                }
            }
            
            ("GET", "/device/rooms") | ("GET", "/api/device/rooms") => {
                let response = handle_rooms_list();
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            ("GET", "/device/types") | ("GET", "/api/device/types") => {
                let response = handle_types_list();
                send_response(&mut stream, "200 OK", &response, None);
            }
         
            ("GET", "/tts") => {
                let text = urldecode(&get_query_arg(query, "text"));
                if text.is_empty() {
                    dt_warning("TTS endpoint called without text");
                    send_response(&mut stream, "400 Bad Request", 
                        r#"{"error":"Missing text parameter"}"#, None);
                    return;
                }
                dt_info(&format!("TTS request: {}", text));
                
                let output = std::process::Command::new("yo")
                    .args(&["say", "--text", &text, "--web"])
                    .output();
            
                match output {
                    Ok(output) if output.status.success() => {
                        let wav_path = String::from_utf8_lossy(&output.stdout).trim().to_string();
                        dt_info(&format!("TTS generated: {}", wav_path));
            
                        match std::fs::read(&wav_path) {
                            Ok(content) => {
                                let response = format!(
                                    "HTTP/1.1 200 OK\r\n\
                                     Content-Type: audio/wav\r\n\
                                     Content-Length: {}\r\n\
                                     Access-Control-Allow-Origin: *\r\n\
                                     Cache-Control: no-cache\r\n\r\n",
                                    content.len()
                                );
            
                                if let Err(e) = stream.write_all(response.as_bytes()) {
                                    dt_error(&format!("Failed to send headers: {}", e));
                                    return;
                                }
            
                                if let Err(e) = stream.write_all(&content) {
                                    dt_error(&format!("Failed to send audio: {}", e));
                                }
                                
                                if let Err(e) = std::fs::remove_file(&wav_path) {
                                    dt_warning(&format!("Failed to remove TTS file {}: {}", wav_path, e));
                                }
                            }
                            Err(e) => {
                                dt_error(&format!("Failed to read WAV file: {}", e));
                                send_response(&mut stream, "500 Internal Server Error", 
                                    r#"{"error":"Failed to read audio"}"#, None);
                            }
                        }
                    }
                    Ok(output) => {
                        let stderr = String::from_utf8_lossy(&output.stderr);
                        dt_error(&format!("TTS command failed: {}", stderr));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"TTS failed: {}"}}"#, stderr), None);
                    }
                    Err(e) => {
                        dt_error(&format!("Failed to run TTS command: {}", e));
                        send_response(&mut stream, "500 Internal Server Error", 
                            &format!(r#"{{"error":"TTS command failed: {}"}}"#, e), None);
                    }
                }
            }
                  
            ("GET", "/do") | ("GET", "/api/do") => {
                let command = get_query_arg(query, "cmd");
                if command.is_empty() {
                    dt_warning("Do endpoint called without command");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Missing cmd parameter"}"#, None);
                    return;
                }
                
                dt_info(&format!("Executing command: {}", command));
                let natural_language = if command.to_lowercase().starts_with("do ") {
                    command[3..].trim().to_string()
                } else {
                    command.trim().to_string()
                };
    
                if natural_language.is_empty() {
                    dt_warning("Empty command after 'do'");
                    send_response(&mut stream, "400 Bad Request", r#"{"error":"Empty command after 'do'"}"#, None);
                    return;
                }
    
                match run_yo_command(&["do", "--input", &natural_language]) {
                    Ok(output) => {
                        let filtered_output: String = output
                            .lines()
                            .filter(|line| !line.contains("MEMORY ADJUSTMENT:"))
                            .filter(|line| !line.contains("[ü¶Üüìú]"))
                            .collect::<Vec<&str>>()
                            .join("\n");        

                        let cleaned_output = filtered_output
                            .replace('‚Æû', "‚ñ∂")
                            .replace('"', "\\\"")
                            .replace('\n', "\\n");
            
                        dt_info(&format!("Command executed successfully: {}", natural_language));
                        let response = format!(r#"{{"status":"success","command":"{}","output":"{}"}}"#, 
                            natural_language, cleaned_output.trim());
                        send_response(&mut stream, "200 OK", &response, None);
                    }
                    Err(error) => {
                        let cleaned_error = error.replace('"', "\\\"").replace('\n', "\\n");
                        dt_error(&format!("Command failed '{}': {}", natural_language, cleaned_error));
                        let response = format!(r#"{{"status":"error","command":"{}","error":"{}"}}"#, 
                            natural_language, cleaned_error.trim());
                        send_response(&mut stream, "500 Internal Server Error", &response, None);
                    }
                }
            }
            
            ("POST", "/upload") | ("POST", "/api/upload") => {
                dt_info("File upload request");
                let response = handle_file_upload(&headers, &body);
                if response.contains("error") {
                    dt_error(&format!("Upload failed: {}", response));
                } else {
                    dt_info("File uploaded successfully");
                }
                send_response(&mut stream, "200 OK", &response, None);
            }
            
            _ => {
                send_response(&mut stream, "404 Not Found", &format!(r#"{{"error":"Endpoint not found","path":"{}"}}"#, raw_path), None);
            }
        }
    }
   
    fn main() {
        setup_ducktrace_logging(None, None);
        let log_file = std::env::var("DT_LOG_FILE")
            .unwrap_or_else(|_| "api.log".to_string());
        let log_path = std::env::var("DT_LOG_PATH")
            .unwrap_or_else(|_| "/home/${config.this.user.me.name}/.config/duckTrace/".to_string());
        let log_level = std::env::var("DT_LOG_LEVEL")
            .unwrap_or_else(|_| "INFO".to_string());
    
        dt_info(&format!("üöÄ Starting yo API server"));
        dt_info(&format!("Log file: {}{}", log_path, log_file));
        dt_info(&format!("Log Level: {}", log_level));
            
        let args: Vec<String> = env::args().collect();
        if args.len() != 3 {
            dt_error("Usage: yo api");
            std::process::exit(1);
        }
    
        let host = &args[1];
        let port = &args[2];
        let address = format!("{}:{}", host, port);
    
        if TcpListener::bind(&address).is_err() {
            dt_error(&format!("‚ùå Port {} is already in use", port));
            std::process::exit(1);
        }
    
        let listener = TcpListener::bind(&address).expect("Failed to bind to address");
        log("Available endpoints:");
        log("  GET /timers                     - List timers");
        log("  GET /alarms                     - List alarms");
        log("  GET /shopping                   - List shopping items");
        log("  GET /reminders                  - List reminders");
        log("  GET /health                     - Health check (no auth required)");
        log("  GET /health/all                 - All health checks (no auth required)");
        log("  GET /do?cmd=...                 - Execute natural language commands");
        log("  GET /browse?path=...            - Browse media directory (legacy)");
        log("  GET /browsev2?path=...          - Browse media directory (improved)");
        log("  GET /add?path=...               - Add file to playlist");
        log("  GET /add_folder?path=...        - Add folder to playlist");
        log("  GET /playlist                   - Get current playlist");
        log("  GET /playlist/remove?index=...  - Remove item from playlist");
        log("  GET /playlist/clear             - Clear playlist");
        log("  GET /playlist/shuffle           - Shuffle playlist");
        log("  GET /tts?text=...               - Text to speech");
        log("  GET /device/list                - List all devices");
        log("  GET /device/rooms               - List devices by room");
        log("  GET /device/types               - List devices by type");
        log("  GET /scene/{scene}              - Activate scene (e.g., /scene/dark)");
        log("  GET /device/{device}/{command}/{value} - Control devices");
        log("      Examples:");
        log("      /device/PC/state/on                     - Turn device on");
        log("      /device/PC/state/off                    - Turn device off");
        log("      /device/PC/brightness/200               - Set brightness");
        log("      /device/PC/color/%23FF5733              - Set color (#FF5733)");
        log("      /device/PC/temperature/300              - Set color temperature");
        log("      /device/PC/state/on/brightness/200      - Combined commands");
        log("  POST /upload                     - Upload files");
        log("üîê Authentication:");
        log("  All endpoints except /health and /health/all require password authentication");
        log("  Use: Authorization: Bearer <password> header");
        log("  Or:  X-API-Key: <password> header");
        log("  Or:  ?password=<password> query parameter");
        log("  Password is read from YO_API_PASSWORD_FILE environment variable");
        log("Press Ctrl+C to stop");
    
        for stream in listener.incoming() {
            match stream {
                Ok(stream) => {
                    std::thread::spawn(move || {
                        handle_request(stream);
                    });
                }
                Err(e) => {
                    dt_warning(&format!("üîå Connection failed: {}", e));
                }
            }
        }
    }
  '';
  
in { 
  networking.firewall.allowedTCPPorts = [9815];

  yo.scripts.api = {
    description = "API endpoints for smart home control, virtual media playlist management, system wide health checks and more.";
    category = "üåê Networking";
    autoStart = builtins.elem config.this.host.hostname [ "homie" ];
    logLevel = "DEBUG";
    parameters = [
      { name = "host"; description = "IP to run server on"; default = "0.0.0.0"; }
      { name = "port"; description = "Port for the service"; default = 9815;  } 
      { name = "dir"; description = "Directory path to build inside"; default = "/home/" + config.this.user.me.name + "/api-rs";  }       
    ];
    helpFooter = '' 
      echo "# üîê Authentication:"
      echo "PASS=\$(cat ${config.house.dashboard.passwordFile} | tr -d '[:space:]')"
      
      echo "# Using Authorization header:"
      echo "curl -H 'Authorization: Bearer \$PASS' http://${mqttHostip}:9815/device/list"
      
      echo "# Using X-API-Key header:"
      echo "curl -H 'X-API-Key: PASS' http://${mqttHostip}:9815/device/list"
      
      echo "# Using query parameter:"
      echo "curl 'http://${mqttHostip}:9815/device/list?password=\$PASS'"
      
      echo "# Media Handling"
      echo "Browse"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/browsev2?path=Movies'"      
      echo "Add file to playlist"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/add?path=/Pool/Movies/movie.mp4'"
      echo "Add entire folder to playlist"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/add_folder?path=/Pool/Movies/Godzilla%20(1998)'"
      echo "Check playlist"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist'"
      echo "Remove item from playlist (0-based index):"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist/remove?index=0'"
      echo "Clear entire playlist:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist/clear'"
      echo "Shuffle playlist:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/playlist/shuffle'"
     
      echo "# Health check (no auth required):"
      echo "curl http://${mqttHostip}:9815/health"
      
      echo "# Text-To-Speech"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/tts?text=Hello%20world"
      
      echo "# Yo Do commands:"
      echo "curl 'http://${mqttHostip}:9815/do?cmd=your%20cmmand%20here&password=\$PASS'"
      
      echo "# Control devices:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/state/on'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/state/off'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/brightness/150'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/color/%23FF5733'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/temperature/300'"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/PC/state/on/brightness/200'"
  
      echo "# Activate a scene:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/scene/dark'"

      echo "# List devices:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/list'"
      echo "# List devices by room:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/rooms'"
      echo "# List devices by type:"
      echo "curl -H 'Authorization: Bearer \$PASS' 'http://${mqttHostip}:9815/device/types'"
      
      echo "# File upload:"
      echo "curl -X POST -H 'X-API-Key: \$PASS' -F 'file=@/path/to/file' 'http://${mqttHostip}:9815/upload'"
    '';
    code = ''
      ${cmdHelpers} 
      HOST="$host"
      PORT="$port"
      tmp=$(mktemp -d)
      trap "rm -rf '$tmp'" EXIT
      mkdir -p "$tmp/src"

      cp ${api-rs} "$tmp/src/main.rs"
      cp ${cargo-toml} "$tmp/Cargo.toml"
      cp ${devices-json} "$tmp/devices.json"
      cp ${scenes-json} "$tmp/scenes.json" 
      cp ${rooms-json} "$tmp/rooms.json"
      cp ${types-json} "$tmp/types.json"
        
      cd "$tmp"

      dt_info "Build complete!"
      
      ${pkgs.cargo}/bin/cargo generate-lockfile
      ${pkgs.cargo}/bin/cargo build --release    
      dt_info "Build complete!"

      dt_info "Starting yo API server (Rust) on $HOST:$PORT" >&2
      echo "Endpoints:" >&2
      echo "  GET /timers     - List timers" >&2
      echo "  GET /alarms     - List alarms" >&2
      echo "  GET /shopping   - List shopping items" >&2
      echo "  GET /health     - Health check" >&2
      echo "  GET /do?cmd=... - Execute natural language commands" >&2
      echo "Press Ctrl+C to stop" >&2

      if [ "$VERBOSE" -ge 1 ]; then
        while true; do
          DEBUG=1 DT_LOG_FILE_PATH="$DT_LOG_PATH$DT_LOG_FILE" YO_API_PASSWORD_FILE="${config.house.dashboard.passwordFile}" ./target/release/api-rs "$HOST" "$PORT"
          EXIT_CODE=$?
          dt_error "api-rs exited with code $EXIT_CODE, restarting in 3 seconds..."
          sleep 3
       done
      fi  

      while true; do
        DT_LOG_FILE_PATH="$DT_LOG_PATH$DT_LOG_FILE" YO_API_PASSWORD_FILE="${config.house.dashboard.passwordFile}" ./target/release/api-rs "$HOST" "$PORT"
        EXIT_CODE=$?
        dt_error "api-rs exited with code $EXIT_CODE, restarting in 3 seconds..."
        sleep 3
      done         
    '';      
    
  };

  environment.systemPackages = [ pkgs.socat pkgs.netcat ];
     
  environment.sessionVariables = {
    YO_API_USER = config.this.user.me.name;
    YO_API_PASSWORD_FILE = config.house.dashboard.passwordFile;

  };}
            </script>
        </div>
    </details>


        <p>
            Now when the API service is up and running, and we have proper authentication on both the dashboard login and the API, we can finally continue creating our next page <i>(tab)</i> on our dashboard - the chat interface! <br><br>
        </p>



        
        <h2 class="section-title">As Previously Shown...</h2>
        
        <p>
            Adding pages to our dashboard follows a simple structure:<br>
            Page number, title, icon for the tab, give it some styling with CSS, symlink required files and insert page code.<br>
            And <strong>Voil√†</strong>, you got yourself a page!<br>
            Here's how I did:<br>
        </p>
        
        
        <div class="callout">
            <p>
                You can find the CSS for the chat page <a href="https://github.com/QuackHack-McBlindy/dotfiles/blob/main/modules/themes/css/chat.css">here</a>.
            </p>
        </div>        
        
        <details class="code-block-container">
            <summary class="code-header">
                <div class="code-lang">‚ñ∂ View Chat Page</div>
            </summary>

            <div class="code-block">
                <pre>
<span class="duck-version"></span>
<span class="clean-version hidden"></span>
                </pre>

                <script type="text/plain" class="duck-source">
{
  config,
  lib,
  self,
  pkgs,
  ...
} : let # ü¶Ü say ‚ñ∂ load dash pages css files
  css = { 
    chat = builtins.readFile ./themes/css/chat.css;
  };
in { 
  house = {
    dashboard = {
      pages = {
        "5" = {
          icon = "fas fa-comments"; # ü¶Ü say ‚ñ∂ font awesome
          title = "chat";
          css = css.chat;
          # ü¶Ü says ‚ñ∂ symlink TTS audio to frontend webserver
          files = { tts = "/var/lib/zigduck/tts"; };
          code = ''
            <div id="chat-container">            
                <div id="chat">

                </div>
                <div id="input-container">
                    <button id="attachment-button" title="Attach file">üìé</button>                
                    <input type="text" id="prompt" placeholder="Qwack something ... ">
                    <input type="file" id="file-input" style="display: none;" multiple>
                    <button id="send-button">ü¶Ü‚Æû</button>
                </div>
                <div id="file-preview" style="display: none;"></div>
            </div>
            
            <script>
                function fixViewportHeight() {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `''${vh}px`);
                    const inputContainer = document.getElementById('input-container');
                    const chat = document.getElementById('chat');
                    if (inputContainer && chat) {
                        const inputHeight = inputContainer.offsetHeight;
                        chat.style.paddingBottom = `''${inputHeight + 20}px`;
                    }
                }

                window.addEventListener('load', fixViewportHeight);
                window.addEventListener('resize', fixViewportHeight);
                window.addEventListener('orientationchange', fixViewportHeight);
       
                // ü¶Ü says ‚Æû click handler 4 fullscreen bubble
                document.addEventListener('click', function(e) {
                  const bubble = e.target.closest('.chat-bubble');
                  
                  if (!bubble) return;
                  if (e.target.closest('button') || 
                      e.target.closest('a') || 
                      e.target.closest('input') ||
                      e.target.closest('video') ||
                      e.target.closest('.remove-file-btn') ||
                      e.target.closest('.playlist-controls')) {
                    return;
                  }
                  
                  // ü¶Ü says ‚Æûtoggle fullscreen
                  bubble.classList.toggle('fullscreen');
                  
                  if (bubble.classList.contains('fullscreen')) {
                    const handleEscape = (event) => {
                      if (event.key === 'Escape') {
                        bubble.classList.remove('fullscreen');
                        document.removeEventListener('keydown', handleEscape);
                      }
                    };
                    document.addEventListener('keydown', handleEscape);
                    const closeHandler = (event) => {
                      if (event.target === bubble || event.target.closest('.chat-bubble') === bubble) {
                        const rect = bubble.getBoundingClientRect();
                        const x = event.clientX;
                        const y = event.clientY;
                        
                        if (x > rect.right - 60 && y < rect.top + 60) {
                          bubble.classList.remove('fullscreen');
                          document.removeEventListener('keydown', handleEscape);
                        }
                      }
                    };
                    
                    bubble.addEventListener('click', closeHandler, { once: true });
                  }
                });       
            
                // ü¶Ü says ‚Æû message history
                let messageHistory = [];
                let historyIndex = -1;

                // ü¶Ü says ‚Æû add to history when message is sent
                function addToHistory(message) {
                    if (!message.trim()) return;
    
                    // ü¶Ü says ‚Æû same as last msg? don't add!
                    if (messageHistory.length > 0 && messageHistory[messageHistory.length - 1] === message) {
                        return;
                    }
                    messageHistory.push(message);
    
                    // ü¶Ü says ‚Æû limit history to 50
                    if (messageHistory.length > 50) {
                        messageHistory.shift();
                    }
                    // ü¶Ü says ‚Æû reset history index to the end
                    historyIndex = messageHistory.length;
                }

                // ü¶Ü says ‚Æû navigate history with up/down keys
                function navigateHistory(direction) {
                    const promptInput = document.getElementById('prompt');
                    if (messageHistory.length === 0) return;
    
                    if (direction === 'up') {
                        if (historyIndex > 0) {
                            historyIndex--;
                        } else {
                            historyIndex = 0;
                        }
                    } else if (direction === 'down') {
                        if (historyIndex < messageHistory.length - 1) {
                            historyIndex++;
                        } else {
                            promptInput.value = "";
                            historyIndex = messageHistory.length;
                            return;
                        }
                    }
    
                    if (historyIndex >= 0 && historyIndex < messageHistory.length) {
                        promptInput.value = messageHistory[historyIndex];
                    }
                }
       
                const AUDIO_CONFIG = {
                    enabled: true,
                    volume: 0.8
                };

                const API_CONFIG = {
                  host: '${mqttHostip}',
                  port: '9815',
                  baseUrl: 'http://${mqttHostip}:9815'
                };       
       
                function getAuthToken() {
                  function getCookie(name) {
                    const value = `; ''${document.cookie}`;
                    const parts = value.split(`; ''${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
    
                    const cookies = document.cookie.split(';').map(c => c.trim());
                    for (const cookie of cookies) {
                      if (cookie.startsWith(name + '=')) {
                        return cookie.substring(name.length + 1);
                      }
                    }
                    return null;
                  }
  
                  const cookiePassword = getCookie('api_password');
                  if (cookiePassword) return cookiePassword;
  
                  return localStorage.getItem('mqttPassword') || 
                         localStorage.getItem('dashboardPassword') || 
                         "";
                }
 
                function showNotification(message, type) {
                    let notification = document.getElementById('chat-notification');
                    if (!notification) {
                        notification = document.createElement('div');
                        notification.id = 'chat-notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: ''${type === 'error' ? '#ff4444' : type === 'success' ? '#4CAF50' : '#2196F3'};
                            color: white;
                            padding: 12px 20px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-family: monospace;
                            font-size: 14px;
                            opacity: 0;
                            transform: translateY(-20px);
                            transition: all 0.3s ease;
                        `;
                        document.body.appendChild(notification);
                    }
    
                    notification.textContent = message;
                    notification.style.background = type === 'error' ? '#ff4444' : type === 'success' ? '#4CAF50' : '#2196F3';
    
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
    
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transform = 'translateY(-20px)';
                    }, 3000);
                }
                      
                let isFirstMessage = true;
                let apiConnected = false;
                let selectedFiles = [];
                let lastTtsCheck = 0;

                const connectionStatus = document.createElement('div');
                connectionStatus.id = 'chat-connection-status';
                connectionStatus.className = 'connection-status disconnected';
                connectionStatus.innerHTML = '<i class="fas fa-plug"></i><span>API: Disconnected</span>';
                document.getElementById('chat-container').insertBefore(connectionStatus, document.getElementById('chat'));
                
                function setupFileUpload() {
                    const attachmentButton = document.getElementById('attachment-button');
                    const fileInput = document.getElementById('file-input');
                    const filePreview = document.getElementById('file-preview');
                    
                    attachmentButton.addEventListener('click', () => {
                        fileInput.click();
                    });
                    
                    fileInput.addEventListener('change', (event) => {
                        selectedFiles = Array.from(event.target.files);
                        updateFilePreview();
                    });
                }

                function hasMarkdownTable(text) {
                    const lines = text.split('\n');
                    let pipeCount = 0;
                    for (const line of lines) {
                        if (line.trim().startsWith('|') && line.includes('|') && line.split('|').length > 2) {
                            pipeCount++;
                        }
                    }             
                }

                function convertMarkdownTableToHTML(text) {
                    const lines = text.split('\n').filter(line => 
                        line.trim().startsWith('|') && line.trim().endsWith('|')
                    );
    
                    if (lines.length < 2) return text;
    
                    const tableData = lines.map(line => 
                        line.split('|')
                            .slice(1, -1)
                            .map(cell => cell.trim())
                    );
    
                    const isSecondRowSeparator = tableData[1] && tableData[1].every(cell => 
                        /^:?-+:?$/.test(cell)
                    );
    
                    const headers = isSecondRowSeparator ? tableData[0] : [];
                    const dataRows = isSecondRowSeparator ? tableData.slice(2) : tableData;
    
                    let html = '<div class="markdown-table-container"><table class="markdown-table">';
                    if (headers.length > 0) {
                        html += '<thead><tr>';
                        headers.forEach(header => {
                            html += `<th>''${header}</th>`;
                        });
                        html += '</tr></thead>';
                    }
    
                    html += '<tbody>';
                    dataRows.forEach(row => {
                        if (row.length === headers.length || headers.length === 0) {
                            row.forEach(cell => {
                                const tag = headers.length === 0 && row === dataRows[0] ? 'th' : 'td';
                                html += `<''${tag}>''${cell}</''${tag}>`;
                            });
                            html += '</tr>';
                        }
                    });
                    html += '</tbody></table></div>';
    
                    return html;
                }
                                         
                function updateFilePreview() {
                    const filePreview = document.getElementById('file-preview');              
                    if (selectedFiles.length === 0) {
                        filePreview.style.display = 'none';
                        filePreview.innerHTML = "";
                        return;
                    }
                    
                    filePreview.style.display = 'block';
                    filePreview.innerHTML = '<strong>Attached files:</strong><br>';           
                    selectedFiles.forEach((file, index) => {
                        const fileElement = document.createElement('div');
                        fileElement.className = 'file-preview-item';
                        fileElement.innerHTML = `
                            üìÑ ''${file.name} (''${formatFileSize(file.size)})
                            <button onclick="removeFile(''${index})" class="remove-file-btn">‚ùå</button>
                        `;
                        filePreview.appendChild(fileElement);
                    });
                }
                
                function removeFile(index) {
                    selectedFiles.splice(index, 1);
                    updateFilePreview();          
                    document.getElementById('file-input').value = "";
                }
                
                function formatFileSize(bytes) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                }
                
                async function uploadFiles() {
                    if (selectedFiles.length === 0) return true;    
                    showTypingIndicator();
                    try {
                        const password = getAuthToken();        
                        for (const file of selectedFiles) {
                            const formData = new FormData();
                            formData.append('file', file);
                            const response = await fetch(API_CONFIG.baseUrl + '/upload?password=' + encodeURIComponent(password), {
                                method: 'POST',
                                body: formData
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`Upload failed: ''${response.status} - ''${errorText}`);
                            }
            
                            const result = await response.json();
                            addAIMessage(`ü¶Ü say ‚Æû Quack safe backed up: ''${file.name} (''${formatFileSize(file.size)})`);
                        }
                        selectedFiles = [];
                        updateFilePreview();
                        document.getElementById('file-input').value = "";
                        return true;
                    } catch (error) {
                        console.error('File upload failed:', error);
                        addErrorMessage(`File upload failed: ''${error.message}`);
                        return false;
                    }
                }
                
                function extractOutputFromResponse(responseText) {
                    try {
                        const data = JSON.parse(responseText);
                        if (data.output) {
                            return data.output;
                        }
                    } catch (e) {
                        console.log('JSON parse failed, trying regex');
                    }         
                    const outputMatch = responseText.match(/"output":"([\s\S]*?)"(?=,|\})/);
                    if (outputMatch && outputMatch[1]) {
                        return outputMatch[1];
                    }
                    
                    return responseText;
                }
                
                function cleanAPIResponse(output) {
                    if (!output) return "Command executed!";         
                    let cleaned = output.replace(/\u001b\[[0-9;]*m/g, "");
                    cleaned = cleaned.replace(/\\n/g, '\n');         
                    return cleaned;
                }
                
                async function checkAPIHealth() {
                    try {
                        const response = await fetch(API_CONFIG.baseUrl + '/health');
                        if (response.ok) {
                            const data = await response.json();
                            updateConnectionStatus(true, 'API: Connected');
                            apiConnected = true;
                            return true;
                        }
                    } catch (error) {
                        console.log('API health check failed:', error);
                    }
                    updateConnectionStatus(false, 'API: Disconnected');
                    apiConnected = false;
                    return false;
                }
                
                function updateConnectionStatus(connected, message) {
                    const statusElement = document.getElementById('chat-connection-status');
                    if (statusElement) {
                        if (connected) {
                            statusElement.innerHTML = '<i class="fas fa-plug"></i><span>' + message + '</span>';
                            statusElement.className = 'connection-status connected';
                        } else {
                            statusElement.innerHTML = '<i class="fas fa-plug"></i><span>' + message + '</span>';
                            statusElement.className = 'connection-status disconnected';
                        }
                    }
                }

                function enhanceContent(content) {
                    // ü¶Ü says ‚Æû cleanup on ile 3!!
                    const cleaned = content
                        .split('\n')
                        .filter(line => !line.includes('Loading fuzzy index from:'))
                        .join('\n');

                    const noAnsi = cleaned.replace(/\x1b\[[0-9;]*m/g, "");
                    const isTerminalOutput = noAnsi.includes('‚îÇ') || noAnsi.includes('‚îå') || 
                                             noAnsi.includes('‚îÄ') || noAnsi.includes('‚îî');
                    if (isTerminalOutput) {
                        return {
                            type: 'terminal',
                            content: noAnsi
                        };
                    } else {
                        // ü¶Ü says ‚Æû text - convert markdown headers to html
                        let html = noAnsi
                            .replace(/# üèÜ(.*)/g, '<h3 style="color: #FFD700; margin: 15px 0 8px 0; font-size: 1.3em; font-weight: bold;">üèÜ$1</h3>')
                            .replace(/# üóûÔ∏è(.*)/g, '<h3 style="color: #4CAF50; margin: 15px 0 8px 0; font-size: 1.3em; font-weight: bold;">üóûÔ∏è$1</h3>')
                            .replace(/### (.*)/g, '<h5 style="color: #2196F3; margin: 12px 0 6px 0; font-weight: bold;">$1</h5>')
                            .replace(/## (.*)/g, '<h4 style="color: #FF9800; margin: 14px 0 7px 0; font-weight: bold;">$1</h4>')
                            .replace(/# (.*)/g, '<h3 style="color: #4CAF50; margin: 16px 0 8px 0; font-size: 1.3em; font-weight: bold;">$1</h3>')
                            .replace(/\n/g, '<br>');        
                        return {
                            type: 'html',
                            content: html
                        };
                    }
                }
            
                // ü¶Ü says ‚Æû let'z make chat handle video/music playlists yo
                function extractVideoUrls(text) {
                    const urlRegex = /https?:\/\/[^\s]+/g;
                    const urls = text.match(urlRegex) || [];
                    return urls.filter(url => {
                        try {
                            const urlObj = new URL(url);
                            const pathname = urlObj.pathname.toLowerCase();
                            const videoExtensions = ['.mp4', '.webm', '.avi', '.mov', '.mkv', '.flv', '.wmv'];
                            const playlistExtensions = ['.m3u', '.m3u8'];
                            
                            if (videoExtensions.some(ext => pathname.endsWith(ext))) {
                                return true;
                            }
                            
                            if (playlistExtensions.some(ext => pathname.endsWith(ext))) {
                                return true;
                            }
                            
                            const streamingKeywords = ['stream', 'hls', 'live', 'm3u8', 'playlist'];
                            const urlLower = url.toLowerCase();
                            return streamingKeywords.some(keyword => urlLower.includes(keyword));
                        } catch (e) {
                            return false;
                        }
                    });
                }
                
                function getVideoMimeType(url) {
                    try {
                        const urlObj = new URL(url);
                        const pathname = urlObj.pathname.toLowerCase();
                        const extension = pathname.includes('.') ? pathname.split('.').pop() : "";
                        
                        const searchParams = new URLSearchParams(urlObj.search);
                        const formatParam = searchParams.get('format') || "";
                        
                        switch(true) {
                            case extension === 'mp4' || formatParam.includes('mp4'):
                                return 'video/mp4';
                            case extension === 'webm' || formatParam.includes('webm'):
                                return 'video/webm';
                            case extension === 'avi':
                                return "";
                            //    return 'video/x-msvideo';
                            case extension === 'mov':
                                return 'video/quicktime';
                            case extension === 'mkv':
                                return "";                      
                            //    return 'video/x-matroska';
                            case extension === 'flv':
                                return 'video/x-flv';
                            case extension === 'wmv':
                                return 'video/x-ms-wmv';
                            case extension === 'm3u' || extension === 'm3u8' || formatParam.includes('hls'):
                                return 'application/vnd.apple.mpegurl';
                            default:
                                if (url.includes('hls') || url.includes('m3u')) {
                                    return 'application/vnd.apple.mpegurl';
                                }
                                return 'video/mp4';
                        }
                    } catch (e) {
                        return 'application/vnd.apple.mpegurl';
                    }
                }

                let hlsJsLoaded = false;
                let hlsJsLoading = false;
                
                function loadHlsJs() {
                    return new Promise((resolve, reject) => {
                        if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                            hlsJsLoaded = true;
                            resolve(true);
                            return;
                        }
                        
                        if (hlsJsLoading) {
                            const checkInterval = setInterval(() => {
                                if (typeof Hls !== 'undefined') {
                                    clearInterval(checkInterval);
                                    hlsJsLoaded = true;
                                    resolve(true);
                                }
                            }, 100);
                            return;
                        }
                        
                        hlsJsLoading = true;
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/hls.js@1.4.10/dist/hls.min.js';
                        script.onload = function() {
                            hlsJsLoading = false;
                            if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                                hlsJsLoaded = true;
                                console.log('ü¶Ü HLS.js loaded successfully');
                                resolve(true);
                            } else {
                                console.warn('ü¶Ü HLS.js loaded but not supported');
                                resolve(false);
                            }
                        };
                        script.onerror = function() {
                            hlsJsLoading = false;
                            console.warn('ü¶Ü Failed to load HLS.js');
                            resolve(false);
                        };
                        document.head.appendChild(script);
                    });
                }
                
                // ü¶Ü says ‚Æû playlist?
                function isPlaylistUrl(url) {
                    try {
                        const urlObj = new URL(url);
                        const pathname = urlObj.pathname.toLowerCase();
                        return pathname.endsWith('.m3u') || 
                               pathname.endsWith('.m3u8') || 
                               url.toLowerCase().includes('m3u8') ||
                               url.toLowerCase().includes('/hls/') ||
                               url.toLowerCase().includes('playlist');
                    } catch (e) {
                        return false;
                    }
                }
                
                // ü¶Üsays‚Æû m3u ?
                async function isSimpleM3U(url) {
                    try {
                        const response = await fetch(url);
                        const text = await response.text();
                        const firstLine = text.split('\n')[0].trim();
                        return !firstLine.startsWith('#');
                    } catch (e) {
                        return false;
                    }
                }
           
                // ü¶Ü says ‚Æû create HLS video player
                function createHlsPlayer(videoUrl, container) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'hls-status';
                    statusDiv.style.fontSize = '0.9em';
                    statusDiv.style.color = '#666';
                    statusDiv.style.marginTop = '5px';
                    statusDiv.textContent = 'Loading HLS stream...';
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'hls-error';
                    errorDiv.style.fontSize = '0.9em';
                    errorDiv.style.color = '#ff4444';
                    errorDiv.style.marginTop = '5px';
                    errorDiv.style.display = 'none';
                    
                    const source = document.createElement('source');
                    source.src = videoUrl;
                    source.type = 'application/vnd.apple.mpegurl';
                    video.appendChild(source);
                    
                    container.appendChild(video);
                    container.appendChild(statusDiv);
                    container.appendChild(errorDiv);
                    
                    loadHlsJs().then(hlsAvailable => {
                        if (hlsAvailable && Hls.isSupported()) {
                            const hls = new Hls({
                                debug: false,
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90
                            });
                            
                            hls.loadSource(videoUrl);
                            hls.attachMedia(video);
                            
                            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                                statusDiv.textContent = 'HLS stream ready';
                                statusDiv.style.color = '#4CAF50';
                                video.play().catch(e => {
                                    console.log('Auto-play prevented:', e);
                                    statusDiv.textContent = 'Click play to start stream';
                                });
                            });
                            
                            hls.on(Hls.Events.ERROR, function(event, data) {
                                console.warn('ü¶Ü HLS error:', data);
                                if (data.fatal) {
                                    switch(data.type) {
                                        case Hls.ErrorTypes.NETWORK_ERROR:
                                            statusDiv.textContent = 'Network error, trying fallback...';
                                            hls.startLoad();
                                            break;
                                        case Hls.ErrorTypes.MEDIA_ERROR:
                                            statusDiv.textContent = 'Media error, trying fallback...';
                                            hls.recoverMediaError();
                                            break;
                                        default:
                                            statusDiv.textContent = 'Stream error, trying native playback...';
                                            hls.destroy();
                                            video.src = videoUrl;
                                            errorDiv.textContent = 'Using native playback (may not work in all browsers)';
                                            errorDiv.style.display = 'block';
                                            break;
                                    }
                                }
                            });
                        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                            statusDiv.textContent = 'Using native HLS playback (Safari/Apple devices)';
                            video.src = videoUrl;
                            video.load();
                        } else {
                            statusDiv.textContent = 'HLS not supported in this browser';
                            statusDiv.style.color = '#ff4444';
                            errorDiv.textContent = 'For HLS streams, use Chrome/Firefox or Safari on Apple devices';
                            errorDiv.style.display = 'block';
                            
                            const link = document.createElement('a');
                            link.href = videoUrl;
                            link.target = '_blank';
                            link.textContent = 'Open stream in external player';
                            link.style.display = 'block';
                            link.style.marginTop = '10px';
                            link.style.color = '#2196F3';
                            errorDiv.appendChild(link);
                        }
                    });
                    
                    return video;
                }
                
                // ü¶Ü says ‚Æû create a player that cycles a playlist
                function createPlaylistPlayer(videoUrls, container, isLocalFile) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';

                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'playlist-controls';
                    controlsDiv.style.marginTop = '10px';
                    controlsDiv.style.fontSize = '0.9em';
                    controlsDiv.style.color = '#666';

                    let currentIndex = 0;
                    let isPlaying = false;

                    // ü¶Ü says ‚Æû load and play specific index
                    function playVideoAtIndex(index) {
                        if (index < 0 || index >= videoUrls.length) return;
                        currentIndex = index;
                        const currentUrl = videoUrls[currentIndex];
        
                        video.src = currentUrl;
                        video.load();
        
                        updateControls();
        
                        if (isPlaying) {
                            video.play().catch(e => {
                                console.log('Auto-play prevented:', e);
                                isPlaying = false;
                            });
                        }
                    }

                    // ü¶Ü says ‚Æû update playback controls
                    function updateControls() {
                        controlsDiv.innerHTML = `
                            <div style="margin-bottom: 5px;">
                                <span>''${currentIndex + 1}/''${videoUrls.length}: ''${videoUrls[currentIndex].split('/').pop() || 'Video'}</span>
                            </div>
                            <div>
                                <button onclick="playPrev()" style="margin-right: 10px; background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚óÄ Prev</button> <button onclick="playNext()" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Next ‚ñ∂</button>                            
                            </div>
                        `;
                    }

                    // ü¶Ü says ‚Æû playback buttons
                    window.playPrev = () => {
                        if (currentIndex > 0) {
                            playVideoAtIndex(currentIndex - 1);
                        }
                    };

                    window.playNext = () => {
                        if (currentIndex < videoUrls.length - 1) {
                            playVideoAtIndex(currentIndex + 1);
                        } else {
                            playVideoAtIndex(0);
                        }
                    };

                    // ü¶Ü says ‚Æû event listener 4 first item ends
                    video.addEventListener('ended', () => {
                        isPlaying = false;
                        if (currentIndex < videoUrls.length - 1) {
                            setTimeout(() => {
                                playNext();
                                video.play().catch(e => console.log('Auto-play prevented after end:', e));
                            }, 500);
                        }
                    });

                    video.addEventListener('play', () => { isPlaying = true; });
                    video.addEventListener('pause', () => { isPlaying = false; });

                    container.appendChild(video);
                    container.appendChild(controlsDiv);
                    playVideoAtIndex(0);

                    return video;
                }
                
                function createRegularVideoPlayer(videoUrl, container) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';
                    // ü¶Ü says ‚Æû crossorigin to handle CORS
                    video.crossOrigin = 'anonymous';

                    const source = document.createElement('source');
                    source.src = videoUrl;
                    source.type = getVideoMimeType(videoUrl);
                    video.appendChild(source);
                    
                    const fallback = document.createElement('p');
                    fallback.textContent = 'Your browser does not support this video format. ';
                    fallback.style.color = '#666';
                    fallback.style.fontSize = '0.9em';
                    fallback.style.marginTop = '5px';
                    
                    const downloadLink = document.createElement('a');
                    downloadLink.href = videoUrl;
                    downloadLink.target = '_blank';
                    downloadLink.textContent = 'Download video';
                    downloadLink.style.color = '#2196F3';
                    downloadLink.style.textDecoration = 'none';
                    downloadLink.style.marginLeft = '5px';
                    
                    fallback.appendChild(downloadLink);
                    video.appendChild(fallback);
                    
                    container.appendChild(video);
                    return video;
                }
                         
                function addAIMessage(content, options = {}) {
                    const chatContainer = document.getElementById('chat');
                    const typingIndicator = document.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        chatContainer.removeChild(typingIndicator);
                    }
                    
                    const videoUrls = extractVideoUrls(content);
                    let textContent = content;
                    
                    videoUrls.forEach(url => {
                        textContent = textContent.replace(url, "").trim();
                    });
                    
                    const enhanced = enhanceContent(textContent);
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'chat-bubble ai-bubble';
                    
                    if (enhanced.type === 'terminal') {
                        const pre = document.createElement('pre');
                        pre.style.cssText = `
                            font-family: 'Fira Code', 'DejaVu Sans Mono', monospace;
                            white-space: pre;
                            overflow-x: auto;
                            margin: 0;
                            padding: 15px;
                            background: #1e1e1e;
                            color: #f0f0f0;
                            border-radius: 10px;
                            border: 1px solid #333;
                            font-size: 13px;
                            line-height: 1.4;
                            max-height: 400px;
                            overflow-y: auto;
                        `;
                        pre.textContent = enhanced.content;
                        aiBubble.appendChild(pre);
                    } else if (textContent.trim()) {
                        aiBubble.innerHTML = enhanced.content;
                    }
                    
                    if (videoUrls.length > 0) {
                        if (textContent.trim()) {
                            const separator = document.createElement('div');
                            separator.style.height = '20px';
                            aiBubble.appendChild(separator);
                        }
                        
                        videoUrls.forEach((videoUrl, index) => {
                            const videoContainer = document.createElement('div');
                            videoContainer.className = 'video-container';
                            
                            const title = document.createElement('div');
                            title.className = 'video-title';
                            title.textContent = `Media: ''${videoUrl.split('/').pop() || 'Stream'}`;
                            title.style.fontWeight = 'bold';
                            title.style.marginBottom = '10px';
                            title.style.color = '#2196F3';
                            videoContainer.appendChild(title);
                            
                            const isLocalFile = videoUrl.startsWith('file://') || videoUrl.startsWith('/');
                            const isPlaylist = isPlaylistUrl(videoUrl);

                            if (isPlaylist) {
                                // ü¶Ü says ‚Æû playlist? fetch and play all
                                (async () => {
                                    try {
                                        const response = await fetch(videoUrl);
                                        const text = await response.text();
                                        const videoUrlsList = text.split('\n')
                                            .map(line => line.trim())
                                            .filter(line => line && !line.startsWith('#') && line.length > 0);

                                        if (videoUrlsList.length === 0) {
                                            videoContainer.innerHTML = 'No valid video URLs found in playlist';
                                            return;
                                        }
                                        console.log('ü¶Ü Playlist detected with', videoUrlsList.length, 'items');

                                        createPlaylistPlayer(videoUrlsList, videoContainer, isLocalFile);
                                    } catch (error) {
                                        console.error('Failed to process playlist:', error);
                                        videoContainer.innerHTML = `Failed to load playlist: ''${error.message}`;
                                    }
                                })();
                            } else {
                                createRegularVideoPlayer(videoUrl, videoContainer, isLocalFile);
                            }
                            
                            const infoDiv = document.createElement('div');
                            infoDiv.style.marginTop = '8px';
                            infoDiv.style.fontSize = '0.85em';
                            infoDiv.style.color = '#666';
                                                        
                            videoContainer.appendChild(infoDiv);
                            aiBubble.appendChild(videoContainer);
                        });
                    }
                    
                    chatContainer.appendChild(aiBubble);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    
                    const playTTSAudio = async () => {
                        try {
                            const response = await fetch('/tts/tts.wav', { method: 'HEAD' });
                            if (!response.ok) return;
                            const lastModified = new Date(response.headers.get('Last-Modified')).getTime();
                            const now = Date.now();
                            const lastCheck = window.lastTtsCheck || 0;
                            
                            if (lastModified > lastCheck && (now - lastModified) < 30000) {
                                const cacheBuster = Date.now();
                                const audio = new Audio(`/tts/tts.wav?cb=''${cacheBuster}`);
                                audio.volume = AUDIO_CONFIG.enabled ? AUDIO_CONFIG.volume : 0;
                                audio.play().catch(error => {
                                    console.warn('Audio playback failed:', error);
                                });
                                window.lastTtsCheck = lastModified;
                            }
                        } catch (error) {
                            console.warn('TTS check failed:', error);
                        }
                    };
                    setTimeout(() => {
                        playTTSAudio().catch(console.error);
                    }, 500);
                }
                
                function createStreamingPlayer(videoUrl, container, isLocalFile) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';
                    video.preload = 'auto';
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'stream-status';
                    statusDiv.style.fontSize = '0.9em';
                    statusDiv.style.color = '#666';
                    statusDiv.style.marginTop = '5px';
                    statusDiv.textContent = 'Testing stream accessibility...';
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'stream-error';
                    errorDiv.style.fontSize = '0.9em';
                    errorDiv.style.color = '#ff4444';
                    errorDiv.style.marginTop = '5px';
                    errorDiv.style.display = 'none';
                    
                    container.appendChild(video);
                    container.appendChild(statusDiv);
                    container.appendChild(errorDiv);
                    
                    testStreamAccessibility(videoUrl).then(accessible => {
                        if (!accessible) {
                            statusDiv.textContent = 'Stream not accessible (CORS/network issue)';
                            statusDiv.style.color = '#ff9800';
                            return;
                        }
                        
                        statusDiv.textContent = 'Stream accessible, loading player...';   
                        loadHlsJs().then(hlsAvailable => {
                            if (hlsAvailable && Hls.isSupported()) {
                                const hls = new Hls({
                                    debug: false,
                                    enableWorker: true,
                                    lowLatencyMode: true,
                                    xhrSetup: function(xhr, url) {
                                        xhr.withCredentials = false;
                                    }
                                });
                                
                                hls.loadSource(videoUrl);
                                hls.attachMedia(video);
                                
                                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                                    statusDiv.textContent = 'Stream ready - click play';
                                    statusDiv.style.color = '#4CAF50';
                                    video.play().catch(e => {
                                        console.log('Auto-play prevented, waiting for user interaction');
                                    });
                                });
                                
                                hls.on(Hls.Events.ERROR, function(event, data) {
                                    console.warn('Stream error:', data);
                                    if (data.fatal) {
                                        hls.destroy();
                                        statusDiv.textContent = 'HLS playback failed';
                                        statusDiv.style.color = '#ff4444';
                                                                               
                                        if (video.canPlayType('application/vnd.apple.mpegurl')) {
                                            video.src = videoUrl;
                                            video.load();
                                        }
                                    }
                                });
                            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                                statusDiv.textContent = 'Using Safari native HLS playback';
                                video.src = videoUrl;
                                video.load();
                            } else {
                                statusDiv.textContent = 'HLS not supported in this browser';
                                statusDiv.style.color = '#ff4444';
                            }
                        });
                    }).catch(error => {
                        statusDiv.textContent = 'Cannot test stream accessibility';
                        statusDiv.style.color = '#ff4444';
                        errorDiv.textContent = `Error: ''${error.message}`;
                        errorDiv.style.display = 'block';
                    });
                }
                
                async function testStreamAccessibility(url) {
                    try {
                        const response = await fetch(url, {
                            method: 'HEAD',
                            mode: 'cors',
                            cache: 'no-cache'
                        });
                        return response.ok;
                    } catch (headError) {
                        console.log('HEAD failed, trying GET with timeout:', headError);        
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 5000);       
                            const response = await fetch(url, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache',
                                signal: controller.signal,
                                headers: {
                                    'Range': 'bytes=0-100'
                                }
                            });
                            
                            clearTimeout(timeoutId);
                            return response.ok;
                        } catch (getError) {
                            console.log('GET also failed:', getError);
                            return false;
                        }
                    }
                }
                              
                // ü¶Ü says ‚Æû FUCK!
                function addErrorMessage(text) {
                    const chatContainer = document.getElementById('chat');
                    const typingIndicator = document.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        chatContainer.removeChild(typingIndicator);
                    }

                    const cleanedText = text
                        .split('\n')
                        .filter(line => !line.includes('Loading fuzzy index from:'))
                        .join('\n');

                    const errorBubble = document.createElement('div');
                    errorBubble.className = 'chat-bubble error-special-bubble';
    
                    // ü¶Ü says ‚Æû extraction
                    const errorMatch = cleanedText.match(/ü¶Ü says ‚Æû fuck ‚ùå[^\n]*/);
                    const errorMessage = errorMatch ? errorMatch[0].replace('ü¶Ü says ‚Æû ', "") : 'Error!';
    
                    errorBubble.innerHTML = `
                        <div class="error-special-text">ü¶Üsays‚Æû''${errorMessage}</div>
                    `;
    
                    chatContainer.appendChild(errorBubble);
    
                    const matches = [];
                    const lines = cleanedText.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/(\d+)%:\s*'([^']+)'\s*->\s*(.*)/);
                        if (match) {
                            const [, percentage, pattern, command] = match;
                            matches.push({ percentage, pattern, command });
                        }
                    });
    
                    if (matches.length > 0) {
                        const suggestionBubble = document.createElement('div');
                        suggestionBubble.className = 'chat-bubble suggestion-header-bubble';
                        suggestionBubble.innerHTML = `
                            <div class="suggestion-header">Did you mean?</div>
                        `;
                        chatContainer.appendChild(suggestionBubble);
        
                        matches.forEach(match => {
                            const matchBubble = document.createElement('div');
                            matchBubble.className = 'chat-bubble suggestion-match-bubble';
                            matchBubble.innerHTML = `
                                <div class="match-percentage">''${match.percentage}% match</div>
                                <div class="match-pattern">''${match.pattern}</div>
                                <div class="match-command">‚Üí ''${match.command}</div>
                            `;

                            matchBubble.style.cursor = 'pointer';
                            matchBubble.addEventListener('click', () => {
                                document.getElementById('prompt').value = match.pattern.replace(/\{[^}]+\}/g, '...');
                                sendMessage();
                            });
                            chatContainer.appendChild(matchBubble);
                        });
                    }
    
                    chatContainer.scrollTop = chatContainer.scrollHeight;
    
                    // ü¶Ü says ‚Æû FUCK.wav
                    const playFailAudio = () => {
                        const cacheBuster = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        const audio = new Audio('/tts/fail.wav?' + cacheBuster);
                        audio.volume = AUDIO_CONFIG.enabled ? AUDIO_CONFIG.volume : 0.8;
                        audio.play().catch(error => {
                            console.warn('Fail audio playback failed:', error);
                        });
                    };
                    setTimeout(playFailAudio, 300);
                }

                function formatCommandError(errorText) {
                  const lines = errorText.split('\n');
                  let html = "";
  
                  lines.forEach(line => {
                    if (line.includes('Input:')) {
                      html += `<div class="error-input"><strong>Your input:</strong> ''${line.replace('Input: ', "")}</div>`;
                    } else if (line.includes('%:')) {
                      const match = line.match(/(\d+)%:\s*'([^']+)'\s*->\s*(.*)/);
                      if (match) {
                        const [, percentage, pattern, command] = match;
                        html += `
                          <div class="close-match">
                            <span class="match-percentage">''${percentage}% match:</span>
                            <code class="match-pattern">''${pattern}</code>
                            <span class="match-command">‚Üí ''${command}</span>
                          </div>
                        `;
                      }
                    } else if (!line.includes('Loading fuzzy index')) {
                      html += line + '<br>';
                    }
                  });
  
                  return html;
                }
                
                function showTypingIndicator() {
                    const chatContainer = document.getElementById('chat');
                    const existingIndicator = document.querySelector('.typing-indicator');
                    if (existingIndicator) {
                        chatContainer.removeChild(existingIndicator);
                    }
                
                    const typingIndicator = document.createElement('div');
                    typingIndicator.className = 'typing-indicator';
                    typingIndicator.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
                    chatContainer.appendChild(typingIndicator);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
                
                async function sendCommandToAPI(command) {
                    if (!apiConnected) {
                        addErrorMessage("Not connected to API. Check if the API server is running.");
                        return false;
                    }
                
                    const uploadSuccess = await uploadFiles();
                    if (!uploadSuccess) {
                        return false;
                    }
                
                    showTypingIndicator(); 
                    try {
                        const lowerCommand = command.toLowerCase();                    
                        if (lowerCommand.startsWith('do ')) {
                            const naturalLanguageCommand = command.substring(3);
                            return await sendNaturalLanguageCommand(naturalLanguageCommand);
                        } else if (lowerCommand.includes('shopping') || lowerCommand.includes('shopping list')) {
                            return await fetchShoppingList();
                        } else if (lowerCommand.includes('reminder') || lowerCommand.includes('remind')) {
                            return await fetchReminders();
                        } else if (lowerCommand.includes('timer')) {
                            return await fetchTimers();
                        } else if (lowerCommand.includes('alarm')) {
                            return await fetchAlarms();
                        } else if (lowerCommand.includes('location') || lowerCommand.includes('where am i')) {
                            return await fetchLocation();
                        } else {
                            return await sendNaturalLanguageCommand(command);
                        }
                    } catch (error) {
                        console.error('API call failed:', error);
                        addErrorMessage("Failed to send command to API. Please check the connection.");
                        return false;
                    }
                }
                
                async function sendNaturalLanguageCommand(command) {
                  try {
                    const password = getAuthToken();
                    const response = await fetch(API_CONFIG.baseUrl + '/do?cmd=' + encodeURIComponent(command) + '&password=' + encodeURIComponent(password));
                    console.error(response); 
                    if (response.ok) {
                      let responseText = await response.text();
                      console.error(responseText); 
                      const rawOutput = extractOutputFromResponse(responseText);
                      console.error(rawOutput);
                      const cleanOutput = cleanAPIResponse(rawOutput);
                      console.error(cleanOutput);
                      const isError = cleanOutput.match(/(No matching command found|System rebuild failed)/);
      
                      if (isError) {   
                        addErrorMessage(cleanOutput);
                      } else {
                        addAIMessage(cleanOutput);
                      }
                      return true;
                    } else {
                      addErrorMessage('API Error: ' + response.status + ' - ' + response.statusText);
                      return false;
                    }
                  } catch (error) {
                    console.error('Yo DO command failed:', error);
                    addAIMessage("Command sent to API! (Check API logs for details)");
                    return true;
                  }
                }

                function sendMessage() {
                    const promptInput = document.getElementById('prompt');
                    const prompt = promptInput.value.trim();
                    const chatContainer = document.getElementById('chat');
                
                    if (prompt === "" && selectedFiles.length === 0) return;
                    if (prompt !== "") {
                        const userBubble = document.createElement('div');
                        userBubble.className = 'chat-bubble user-bubble';
                        userBubble.textContent = prompt;
                        chatContainer.appendChild(userBubble);
                        addToHistory(prompt);
                    }             
                    promptInput.value = "";
                    historyIndex = messageHistory.length;
                    chatContainer.scrollTop = chatContainer.scrollHeight;          
                    sendCommandToAPI(prompt);         
                    isFirstMessage = false;
                }
                
                function sendSuggestion(element) {
                    const text = element.textContent;
                    document.getElementById('prompt').value = text;
                    sendMessage();
                }
                
                function checkEnter(event) {
                    if (event.key === 'Enter') {
                        sendMessage();
                    } else if (event.key === 'ArrowUp') {
                        event.preventDefault();
                        navigateHistory('up');
                    } else if (event.key === 'ArrowDown') {
                        event.preventDefault();
                        navigateHistory('down');
                    }
                }
               
                setupFileUpload();
                checkAPIHealth();     
                document.getElementById('prompt').addEventListener('keydown', checkEnter);
                document.getElementById('send-button').addEventListener('click', sendMessage);        
                document.querySelectorAll('.suggestion-bubble').forEach(bubble => {
                    bubble.addEventListener('click', function() {
                        sendSuggestion(this);
                    });
                });
                setTimeout(() => {
                    if (isFirstMessage) {
                        addAIMessage("Quack quack! I'm a ü¶Ü here to help! Qwack me a question yo!");
                    }
                }, 2000);

                setInterval(checkAPIHealth, 30000);
            <\/script>
          '';
        };
      };
    };
    
  };}
                </script>

                <script type="text/plain" class="clean-source">
{
  config,
  lib,
  self,
  pkgs,
  ...
} : let
  css = { 
    chat = builtins.readFile ./themes/css/chat.css;
  };
in { 
  house = {
    dashboard = {
      pages = {
        "5" = {
          icon = "fas fa-comments";
          title = "chat";
          css = css.chat;
          files = { tts = "/var/lib/zigduck/tts"; };
          code = ''
            <div id="chat-container">            
                <div id="chat">

                </div>
                <div id="input-container">
                    <button id="attachment-button" title="Attach file">üìé</button>                
                    <input type="text" id="prompt" placeholder="Qwack something ... ">
                    <input type="file" id="file-input" style="display: none;" multiple>
                    <button id="send-button">ü¶Ü‚Æû</button>
                </div>
                <div id="file-preview" style="display: none;"></div>
            </div>
            
            <script>
                function fixViewportHeight() {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `''${vh}px`);
                    const inputContainer = document.getElementById('input-container');
                    const chat = document.getElementById('chat');
                    if (inputContainer && chat) {
                        const inputHeight = inputContainer.offsetHeight;
                        chat.style.paddingBottom = `''${inputHeight + 20}px`;
                    }
                }

                window.addEventListener('load', fixViewportHeight);
                window.addEventListener('resize', fixViewportHeight);
                window.addEventListener('orientationchange', fixViewportHeight);
       
                document.addEventListener('click', function(e) {
                  const bubble = e.target.closest('.chat-bubble');
                  
                  if (!bubble) return;
                  if (e.target.closest('button') || 
                      e.target.closest('a') || 
                      e.target.closest('input') ||
                      e.target.closest('video') ||
                      e.target.closest('.remove-file-btn') ||
                      e.target.closest('.playlist-controls')) {
                    return;
                  }
                  
                  bubble.classList.toggle('fullscreen');
                  
                  if (bubble.classList.contains('fullscreen')) {
                    const handleEscape = (event) => {
                      if (event.key === 'Escape') {
                        bubble.classList.remove('fullscreen');
                        document.removeEventListener('keydown', handleEscape);
                      }
                    };
                    document.addEventListener('keydown', handleEscape);
                    const closeHandler = (event) => {
                      if (event.target === bubble || event.target.closest('.chat-bubble') === bubble) {
                        const rect = bubble.getBoundingClientRect();
                        const x = event.clientX;
                        const y = event.clientY;
                        
                        if (x > rect.right - 60 && y < rect.top + 60) {
                          bubble.classList.remove('fullscreen');
                          document.removeEventListener('keydown', handleEscape);
                        }
                      }
                    };
                    
                    bubble.addEventListener('click', closeHandler, { once: true });
                  }
                });       
       
                let messageHistory = [];
                let historyIndex = -1;

                function addToHistory(message) {
                    if (!message.trim()) return;
    
                    if (messageHistory.length > 0 && messageHistory[messageHistory.length - 1] === message) {
                        return;
                    }
                    messageHistory.push(message);
    
                    if (messageHistory.length > 50) {
                        messageHistory.shift();
                    }
                    historyIndex = messageHistory.length;
                }

                function navigateHistory(direction) {
                    const promptInput = document.getElementById('prompt');
                    if (messageHistory.length === 0) return;
    
                    if (direction === 'up') {
                        if (historyIndex > 0) {
                            historyIndex--;
                        } else {
                            historyIndex = 0;
                        }
                    } else if (direction === 'down') {
                        if (historyIndex < messageHistory.length - 1) {
                            historyIndex++;
                        } else {
                            promptInput.value = "";
                            historyIndex = messageHistory.length;
                            return;
                        }
                    }
    
                    if (historyIndex >= 0 && historyIndex < messageHistory.length) {
                        promptInput.value = messageHistory[historyIndex];
                    }
                }
       
                const AUDIO_CONFIG = {
                    enabled: true,
                    volume: 0.8
                };

                const API_CONFIG = {
                  host: '${mqttHostip}',
                  port: '9815',
                  baseUrl: 'http://${mqttHostip}:9815'
                };       
       
                function getAuthToken() {
                  function getCookie(name) {
                    const value = `; ''${document.cookie}`;
                    const parts = value.split(`; ''${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
    
                    const cookies = document.cookie.split(';').map(c => c.trim());
                    for (const cookie of cookies) {
                      if (cookie.startsWith(name + '=')) {
                        return cookie.substring(name.length + 1);
                      }
                    }
                    return null;
                  }
  
                  const cookiePassword = getCookie('api_password');
                  if (cookiePassword) return cookiePassword;
  
                  return localStorage.getItem('mqttPassword') || 
                         localStorage.getItem('dashboardPassword') || 
                         "";
                }
 
                function showNotification(message, type) {
                    let notification = document.getElementById('chat-notification');
                    if (!notification) {
                        notification = document.createElement('div');
                        notification.id = 'chat-notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: ''${type === 'error' ? '#ff4444' : type === 'success' ? '#4CAF50' : '#2196F3'};
                            color: white;
                            padding: 12px 20px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-family: monospace;
                            font-size: 14px;
                            opacity: 0;
                            transform: translateY(-20px);
                            transition: all 0.3s ease;
                        `;
                        document.body.appendChild(notification);
                    }
    
                    notification.textContent = message;
                    notification.style.background = type === 'error' ? '#ff4444' : type === 'success' ? '#4CAF50' : '#2196F3';
    
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
    
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transform = 'translateY(-20px)';
                    }, 3000);
                }
                      
                let isFirstMessage = true;
                let apiConnected = false;
                let selectedFiles = [];
                let lastTtsCheck = 0;

                const connectionStatus = document.createElement('div');
                connectionStatus.id = 'chat-connection-status';
                connectionStatus.className = 'connection-status disconnected';
                connectionStatus.innerHTML = '<i class="fas fa-plug"></i><span>API: Disconnected</span>';
                document.getElementById('chat-container').insertBefore(connectionStatus, document.getElementById('chat'));
                
                function setupFileUpload() {
                    const attachmentButton = document.getElementById('attachment-button');
                    const fileInput = document.getElementById('file-input');
                    const filePreview = document.getElementById('file-preview');
                    
                    attachmentButton.addEventListener('click', () => {
                        fileInput.click();
                    });
                    
                    fileInput.addEventListener('change', (event) => {
                        selectedFiles = Array.from(event.target.files);
                        updateFilePreview();
                    });
                }

                function hasMarkdownTable(text) {
                    const lines = text.split('\n');
                    let pipeCount = 0;
                    for (const line of lines) {
                        if (line.trim().startsWith('|') && line.includes('|') && line.split('|').length > 2) {
                            pipeCount++;
                        }
                    }             
                }

                function convertMarkdownTableToHTML(text) {
                    const lines = text.split('\n').filter(line => 
                        line.trim().startsWith('|') && line.trim().endsWith('|')
                    );
    
                    if (lines.length < 2) return text;
    
                    const tableData = lines.map(line => 
                        line.split('|')
                            .slice(1, -1)
                            .map(cell => cell.trim())
                    );
    
                    const isSecondRowSeparator = tableData[1] && tableData[1].every(cell => 
                        /^:?-+:?$/.test(cell)
                    );
    
                    const headers = isSecondRowSeparator ? tableData[0] : [];
                    const dataRows = isSecondRowSeparator ? tableData.slice(2) : tableData;
    
                    let html = '<div class="markdown-table-container"><table class="markdown-table">';
                    if (headers.length > 0) {
                        html += '<thead><tr>';
                        headers.forEach(header => {
                            html += `<th>''${header}</th>`;
                        });
                        html += '</tr></thead>';
                    }
    
                    html += '<tbody>';
                    dataRows.forEach(row => {
                        if (row.length === headers.length || headers.length === 0) {
                            row.forEach(cell => {
                                const tag = headers.length === 0 && row === dataRows[0] ? 'th' : 'td';
                                html += `<''${tag}>''${cell}</''${tag}>`;
                            });
                            html += '</tr>';
                        }
                    });
                    html += '</tbody></table></div>';
    
                    return html;
                }
                                         
                function updateFilePreview() {
                    const filePreview = document.getElementById('file-preview');              
                    if (selectedFiles.length === 0) {
                        filePreview.style.display = 'none';
                        filePreview.innerHTML = "";
                        return;
                    }
                    
                    filePreview.style.display = 'block';
                    filePreview.innerHTML = '<strong>Attached files:</strong><br>';           
                    selectedFiles.forEach((file, index) => {
                        const fileElement = document.createElement('div');
                        fileElement.className = 'file-preview-item';
                        fileElement.innerHTML = `
                            üìÑ ''${file.name} (''${formatFileSize(file.size)})
                            <button onclick="removeFile(''${index})" class="remove-file-btn">‚ùå</button>
                        `;
                        filePreview.appendChild(fileElement);
                    });
                }
                
                function removeFile(index) {
                    selectedFiles.splice(index, 1);
                    updateFilePreview();          
                    document.getElementById('file-input').value = "";
                }
                
                function formatFileSize(bytes) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                }
                
                async function uploadFiles() {
                    if (selectedFiles.length === 0) return true;    
                    showTypingIndicator();
                    try {
                        const password = getAuthToken();        
                        for (const file of selectedFiles) {
                            const formData = new FormData();
                            formData.append('file', file);
                            const response = await fetch(API_CONFIG.baseUrl + '/upload?password=' + encodeURIComponent(password), {
                                method: 'POST',
                                body: formData
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`Upload failed: ''${response.status} - ''${errorText}`);
                            }
            
                            const result = await response.json();
                            addAIMessage(`ü¶Ü say ‚Æû Quack safe backed up: ''${file.name} (''${formatFileSize(file.size)})`);
                        }
                        selectedFiles = [];
                        updateFilePreview();
                        document.getElementById('file-input').value = "";
                        return true;
                    } catch (error) {
                        console.error('File upload failed:', error);
                        addErrorMessage(`File upload failed: ''${error.message}`);
                        return false;
                    }
                }
                
                function extractOutputFromResponse(responseText) {
                    try {
                        const data = JSON.parse(responseText);
                        if (data.output) {
                            return data.output;
                        }
                    } catch (e) {
                        console.log('JSON parse failed, trying regex');
                    }         
                    const outputMatch = responseText.match(/"output":"([\s\S]*?)"(?=,|\})/);
                    if (outputMatch && outputMatch[1]) {
                        return outputMatch[1];
                    }
                    
                    return responseText;
                }
                
                function cleanAPIResponse(output) {
                    if (!output) return "Command executed!";         
                    let cleaned = output.replace(/\u001b\[[0-9;]*m/g, "");
                    cleaned = cleaned.replace(/\\n/g, '\n');         
                    return cleaned;
                }
                
                async function checkAPIHealth() {
                    try {
                        const response = await fetch(API_CONFIG.baseUrl + '/health');
                        if (response.ok) {
                            const data = await response.json();
                            updateConnectionStatus(true, 'API: Connected');
                            apiConnected = true;
                            return true;
                        }
                    } catch (error) {
                        console.log('API health check failed:', error);
                    }
                    updateConnectionStatus(false, 'API: Disconnected');
                    apiConnected = false;
                    return false;
                }
                
                function updateConnectionStatus(connected, message) {
                    const statusElement = document.getElementById('chat-connection-status');
                    if (statusElement) {
                        if (connected) {
                            statusElement.innerHTML = '<i class="fas fa-plug"></i><span>' + message + '</span>';
                            statusElement.className = 'connection-status connected';
                        } else {
                            statusElement.innerHTML = '<i class="fas fa-plug"></i><span>' + message + '</span>';
                            statusElement.className = 'connection-status disconnected';
                        }
                    }
                }

                function enhanceContent(content) {
                    const cleaned = content
                        .split('\n')
                        .filter(line => !line.includes('Loading fuzzy index from:'))
                        .join('\n');

                    const noAnsi = cleaned.replace(/\x1b\[[0-9;]*m/g, "");
                    const isTerminalOutput = noAnsi.includes('‚îÇ') || noAnsi.includes('‚îå') || 
                                             noAnsi.includes('‚îÄ') || noAnsi.includes('‚îî');
                    if (isTerminalOutput) {
                        return {
                            type: 'terminal',
                            content: noAnsi
                        };
                    } else {
                        let html = noAnsi
                            .replace(/# üèÜ(.*)/g, '<h3 style="color: #FFD700; margin: 15px 0 8px 0; font-size: 1.3em; font-weight: bold;">üèÜ$1</h3>')
                            .replace(/# üóûÔ∏è(.*)/g, '<h3 style="color: #4CAF50; margin: 15px 0 8px 0; font-size: 1.3em; font-weight: bold;">üóûÔ∏è$1</h3>')
                            .replace(/### (.*)/g, '<h5 style="color: #2196F3; margin: 12px 0 6px 0; font-weight: bold;">$1</h5>')
                            .replace(/## (.*)/g, '<h4 style="color: #FF9800; margin: 14px 0 7px 0; font-weight: bold;">$1</h4>')
                            .replace(/# (.*)/g, '<h3 style="color: #4CAF50; margin: 16px 0 8px 0; font-size: 1.3em; font-weight: bold;">$1</h3>')
                            .replace(/\n/g, '<br>');        
                        return {
                            type: 'html',
                            content: html
                        };
                    }
                }
            
                function extractVideoUrls(text) {
                    const urlRegex = /https?:\/\/[^\s]+/g;
                    const urls = text.match(urlRegex) || [];
                    return urls.filter(url => {
                        try {
                            const urlObj = new URL(url);
                            const pathname = urlObj.pathname.toLowerCase();
                            const videoExtensions = ['.mp4', '.webm', '.avi', '.mov', '.mkv', '.flv', '.wmv'];
                            const playlistExtensions = ['.m3u', '.m3u8'];
                            
                            if (videoExtensions.some(ext => pathname.endsWith(ext))) {
                                return true;
                            }
                            
                            if (playlistExtensions.some(ext => pathname.endsWith(ext))) {
                                return true;
                            }
                            
                            const streamingKeywords = ['stream', 'hls', 'live', 'm3u8', 'playlist'];
                            const urlLower = url.toLowerCase();
                            return streamingKeywords.some(keyword => urlLower.includes(keyword));
                        } catch (e) {
                            return false;
                        }
                    });
                }
                
                function getVideoMimeType(url) {
                    try {
                        const urlObj = new URL(url);
                        const pathname = urlObj.pathname.toLowerCase();
                        const extension = pathname.includes('.') ? pathname.split('.').pop() : "";
                        
                        const searchParams = new URLSearchParams(urlObj.search);
                        const formatParam = searchParams.get('format') || "";
                        
                        switch(true) {
                            case extension === 'mp4' || formatParam.includes('mp4'):
                                return 'video/mp4';
                            case extension === 'webm' || formatParam.includes('webm'):
                                return 'video/webm';
                            case extension === 'avi':
                                return "";
                            //    return 'video/x-msvideo';
                            case extension === 'mov':
                                return 'video/quicktime';
                            case extension === 'mkv':
                                return "";                      
                            //    return 'video/x-matroska';
                            case extension === 'flv':
                                return 'video/x-flv';
                            case extension === 'wmv':
                                return 'video/x-ms-wmv';
                            case extension === 'm3u' || extension === 'm3u8' || formatParam.includes('hls'):
                                return 'application/vnd.apple.mpegurl';
                            default:
                                if (url.includes('hls') || url.includes('m3u')) {
                                    return 'application/vnd.apple.mpegurl';
                                }
                                return 'video/mp4';
                        }
                    } catch (e) {
                        return 'application/vnd.apple.mpegurl';
                    }
                }

                let hlsJsLoaded = false;
                let hlsJsLoading = false;
                
                function loadHlsJs() {
                    return new Promise((resolve, reject) => {
                        if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                            hlsJsLoaded = true;
                            resolve(true);
                            return;
                        }
                        
                        if (hlsJsLoading) {
                            const checkInterval = setInterval(() => {
                                if (typeof Hls !== 'undefined') {
                                    clearInterval(checkInterval);
                                    hlsJsLoaded = true;
                                    resolve(true);
                                }
                            }, 100);
                            return;
                        }
                        
                        hlsJsLoading = true;
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/hls.js@1.4.10/dist/hls.min.js';
                        script.onload = function() {
                            hlsJsLoading = false;
                            if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                                hlsJsLoaded = true;
                                console.log('ü¶Ü HLS.js loaded successfully');
                                resolve(true);
                            } else {
                                console.warn('ü¶Ü HLS.js loaded but not supported');
                                resolve(false);
                            }
                        };
                        script.onerror = function() {
                            hlsJsLoading = false;
                            console.warn('ü¶Ü Failed to load HLS.js');
                            resolve(false);
                        };
                        document.head.appendChild(script);
                    });
                }
                
                function isPlaylistUrl(url) {
                    try {
                        const urlObj = new URL(url);
                        const pathname = urlObj.pathname.toLowerCase();
                        return pathname.endsWith('.m3u') || 
                               pathname.endsWith('.m3u8') || 
                               url.toLowerCase().includes('m3u8') ||
                               url.toLowerCase().includes('/hls/') ||
                               url.toLowerCase().includes('playlist');
                    } catch (e) {
                        return false;
                    }
                }
                
                async function isSimpleM3U(url) {
                    try {
                        const response = await fetch(url);
                        const text = await response.text();
                        const firstLine = text.split('\n')[0].trim();
                        return !firstLine.startsWith('#');
                    } catch (e) {
                        return false;
                    }
                }
           
                function createHlsPlayer(videoUrl, container) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'hls-status';
                    statusDiv.style.fontSize = '0.9em';
                    statusDiv.style.color = '#666';
                    statusDiv.style.marginTop = '5px';
                    statusDiv.textContent = 'Loading HLS stream...';
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'hls-error';
                    errorDiv.style.fontSize = '0.9em';
                    errorDiv.style.color = '#ff4444';
                    errorDiv.style.marginTop = '5px';
                    errorDiv.style.display = 'none';
                    
                    const source = document.createElement('source');
                    source.src = videoUrl;
                    source.type = 'application/vnd.apple.mpegurl';
                    video.appendChild(source);
                    
                    container.appendChild(video);
                    container.appendChild(statusDiv);
                    container.appendChild(errorDiv);
                    
                    loadHlsJs().then(hlsAvailable => {
                        if (hlsAvailable && Hls.isSupported()) {
                            const hls = new Hls({
                                debug: false,
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90
                            });
                            
                            hls.loadSource(videoUrl);
                            hls.attachMedia(video);
                            
                            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                                statusDiv.textContent = 'HLS stream ready';
                                statusDiv.style.color = '#4CAF50';
                                video.play().catch(e => {
                                    console.log('Auto-play prevented:', e);
                                    statusDiv.textContent = 'Click play to start stream';
                                });
                            });
                            
                            hls.on(Hls.Events.ERROR, function(event, data) {
                                console.warn('ü¶Ü HLS error:', data);
                                if (data.fatal) {
                                    switch(data.type) {
                                        case Hls.ErrorTypes.NETWORK_ERROR:
                                            statusDiv.textContent = 'Network error, trying fallback...';
                                            hls.startLoad();
                                            break;
                                        case Hls.ErrorTypes.MEDIA_ERROR:
                                            statusDiv.textContent = 'Media error, trying fallback...';
                                            hls.recoverMediaError();
                                            break;
                                        default:
                                            statusDiv.textContent = 'Stream error, trying native playback...';
                                            hls.destroy();
                                            video.src = videoUrl;
                                            errorDiv.textContent = 'Using native playback (may not work in all browsers)';
                                            errorDiv.style.display = 'block';
                                            break;
                                    }
                                }
                            });
                        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                            statusDiv.textContent = 'Using native HLS playback (Safari/Apple devices)';
                            video.src = videoUrl;
                            video.load();
                        } else {
                            statusDiv.textContent = 'HLS not supported in this browser';
                            statusDiv.style.color = '#ff4444';
                            errorDiv.textContent = 'For HLS streams, use Chrome/Firefox or Safari on Apple devices';
                            errorDiv.style.display = 'block';
                            
                            const link = document.createElement('a');
                            link.href = videoUrl;
                            link.target = '_blank';
                            link.textContent = 'Open stream in external player';
                            link.style.display = 'block';
                            link.style.marginTop = '10px';
                            link.style.color = '#2196F3';
                            errorDiv.appendChild(link);
                        }
                    });
                    
                    return video;
                }
                
                function createPlaylistPlayer(videoUrls, container, isLocalFile) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';

                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'playlist-controls';
                    controlsDiv.style.marginTop = '10px';
                    controlsDiv.style.fontSize = '0.9em';
                    controlsDiv.style.color = '#666';

                    let currentIndex = 0;
                    let isPlaying = false;

                    function playVideoAtIndex(index) {
                        if (index < 0 || index >= videoUrls.length) return;
                        currentIndex = index;
                        const currentUrl = videoUrls[currentIndex];
        
                        video.src = currentUrl;
                        video.load();
        
                        updateControls();
        
                        if (isPlaying) {
                            video.play().catch(e => {
                                console.log('Auto-play prevented:', e);
                                isPlaying = false;
                            });
                        }
                    }

                    function updateControls() {
                        controlsDiv.innerHTML = `
                            <div style="margin-bottom: 5px;">
                                <span>''${currentIndex + 1}/''${videoUrls.length}: ''${videoUrls[currentIndex].split('/').pop() || 'Video'}</span>
                            </div>
                            <div>
                                <button onclick="playPrev()" style="margin-right: 10px; background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚óÄ Prev</button> <button onclick="playNext()" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Next ‚ñ∂</button>                            
                            </div>
                        `;
                    }

                    window.playPrev = () => {
                        if (currentIndex > 0) {
                            playVideoAtIndex(currentIndex - 1);
                        }
                    };

                    window.playNext = () => {
                        if (currentIndex < videoUrls.length - 1) {
                            playVideoAtIndex(currentIndex + 1);
                        } else {
                            playVideoAtIndex(0);
                        }
                    };

                    video.addEventListener('ended', () => {
                        isPlaying = false;
                        if (currentIndex < videoUrls.length - 1) {
                            setTimeout(() => {
                                playNext();
                                video.play().catch(e => console.log('Auto-play prevented after end:', e));
                            }, 500);
                        }
                    });

                    video.addEventListener('play', () => { isPlaying = true; });
                    video.addEventListener('pause', () => { isPlaying = false; });

                    container.appendChild(video);
                    container.appendChild(controlsDiv);
                    playVideoAtIndex(0);

                    return video;
                }
                
                function createRegularVideoPlayer(videoUrl, container) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';
                    video.crossOrigin = 'anonymous';

                    const source = document.createElement('source');
                    source.src = videoUrl;
                    source.type = getVideoMimeType(videoUrl);
                    video.appendChild(source);
                    
                    const fallback = document.createElement('p');
                    fallback.textContent = 'Your browser does not support this video format. ';
                    fallback.style.color = '#666';
                    fallback.style.fontSize = '0.9em';
                    fallback.style.marginTop = '5px';
                    
                    const downloadLink = document.createElement('a');
                    downloadLink.href = videoUrl;
                    downloadLink.target = '_blank';
                    downloadLink.textContent = 'Download video';
                    downloadLink.style.color = '#2196F3';
                    downloadLink.style.textDecoration = 'none';
                    downloadLink.style.marginLeft = '5px';
                    
                    fallback.appendChild(downloadLink);
                    video.appendChild(fallback);
                    
                    container.appendChild(video);
                    return video;
                }
                         
                function addAIMessage(content, options = {}) {
                    const chatContainer = document.getElementById('chat');
                    const typingIndicator = document.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        chatContainer.removeChild(typingIndicator);
                    }
                    
                    const videoUrls = extractVideoUrls(content);
                    let textContent = content;
                    
                    videoUrls.forEach(url => {
                        textContent = textContent.replace(url, "").trim();
                    });
                    
                    const enhanced = enhanceContent(textContent);
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'chat-bubble ai-bubble';
                    
                    if (enhanced.type === 'terminal') {
                        const pre = document.createElement('pre');
                        pre.style.cssText = `
                            font-family: 'Fira Code', 'DejaVu Sans Mono', monospace;
                            white-space: pre;
                            overflow-x: auto;
                            margin: 0;
                            padding: 15px;
                            background: #1e1e1e;
                            color: #f0f0f0;
                            border-radius: 10px;
                            border: 1px solid #333;
                            font-size: 13px;
                            line-height: 1.4;
                            max-height: 400px;
                            overflow-y: auto;
                        `;
                        pre.textContent = enhanced.content;
                        aiBubble.appendChild(pre);
                    } else if (textContent.trim()) {
                        aiBubble.innerHTML = enhanced.content;
                    }
                    
                    if (videoUrls.length > 0) {
                        if (textContent.trim()) {
                            const separator = document.createElement('div');
                            separator.style.height = '20px';
                            aiBubble.appendChild(separator);
                        }
                        
                        videoUrls.forEach((videoUrl, index) => {
                            const videoContainer = document.createElement('div');
                            videoContainer.className = 'video-container';
                            
                            const title = document.createElement('div');
                            title.className = 'video-title';
                            title.textContent = `Media: ''${videoUrl.split('/').pop() || 'Stream'}`;
                            title.style.fontWeight = 'bold';
                            title.style.marginBottom = '10px';
                            title.style.color = '#2196F3';
                            videoContainer.appendChild(title);
                            
                            const isLocalFile = videoUrl.startsWith('file://') || videoUrl.startsWith('/');
                            const isPlaylist = isPlaylistUrl(videoUrl);

                            if (isPlaylist) {
                                (async () => {
                                    try {
                                        const response = await fetch(videoUrl);
                                        const text = await response.text();
                                        const videoUrlsList = text.split('\n')
                                            .map(line => line.trim())
                                            .filter(line => line && !line.startsWith('#') && line.length > 0);

                                        if (videoUrlsList.length === 0) {
                                            videoContainer.innerHTML = 'No valid video URLs found in playlist';
                                            return;
                                        }
                                        console.log('ü¶Ü Playlist detected with', videoUrlsList.length, 'items');

                                        createPlaylistPlayer(videoUrlsList, videoContainer, isLocalFile);
                                    } catch (error) {
                                        console.error('Failed to process playlist:', error);
                                        videoContainer.innerHTML = `Failed to load playlist: ''${error.message}`;
                                    }
                                })();
                            } else {
                                createRegularVideoPlayer(videoUrl, videoContainer, isLocalFile);
                            }
                            
                            const infoDiv = document.createElement('div');
                            infoDiv.style.marginTop = '8px';
                            infoDiv.style.fontSize = '0.85em';
                            infoDiv.style.color = '#666';
                                                        
                            videoContainer.appendChild(infoDiv);
                            aiBubble.appendChild(videoContainer);
                        });
                    }
                    
                    chatContainer.appendChild(aiBubble);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    
                    const playTTSAudio = async () => {
                        try {
                            const response = await fetch('/tts/tts.wav', { method: 'HEAD' });
                            if (!response.ok) return;
                            const lastModified = new Date(response.headers.get('Last-Modified')).getTime();
                            const now = Date.now();
                            const lastCheck = window.lastTtsCheck || 0;
                            
                            if (lastModified > lastCheck && (now - lastModified) < 30000) {
                                const cacheBuster = Date.now();
                                const audio = new Audio(`/tts/tts.wav?cb=''${cacheBuster}`);
                                audio.volume = AUDIO_CONFIG.enabled ? AUDIO_CONFIG.volume : 0;
                                audio.play().catch(error => {
                                    console.warn('Audio playback failed:', error);
                                });
                                window.lastTtsCheck = lastModified;
                            }
                        } catch (error) {
                            console.warn('TTS check failed:', error);
                        }
                    };
                    setTimeout(() => {
                        playTTSAudio().catch(console.error);
                    }, 500);
                }
                
                function createStreamingPlayer(videoUrl, container, isLocalFile) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.borderRadius = '8px';
                    video.style.background = '#000';
                    video.style.marginBottom = '10px';
                    video.preload = 'auto';
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'stream-status';
                    statusDiv.style.fontSize = '0.9em';
                    statusDiv.style.color = '#666';
                    statusDiv.style.marginTop = '5px';
                    statusDiv.textContent = 'Testing stream accessibility...';
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'stream-error';
                    errorDiv.style.fontSize = '0.9em';
                    errorDiv.style.color = '#ff4444';
                    errorDiv.style.marginTop = '5px';
                    errorDiv.style.display = 'none';
                    
                    container.appendChild(video);
                    container.appendChild(statusDiv);
                    container.appendChild(errorDiv);
                    
                    testStreamAccessibility(videoUrl).then(accessible => {
                        if (!accessible) {
                            statusDiv.textContent = 'Stream not accessible (CORS/network issue)';
                            statusDiv.style.color = '#ff9800';
                            return;
                        }
                        
                        statusDiv.textContent = 'Stream accessible, loading player...';   
                        loadHlsJs().then(hlsAvailable => {
                            if (hlsAvailable && Hls.isSupported()) {
                                const hls = new Hls({
                                    debug: false,
                                    enableWorker: true,
                                    lowLatencyMode: true,
                                    xhrSetup: function(xhr, url) {
                                        xhr.withCredentials = false;
                                    }
                                });
                                
                                hls.loadSource(videoUrl);
                                hls.attachMedia(video);
                                
                                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                                    statusDiv.textContent = 'Stream ready - click play';
                                    statusDiv.style.color = '#4CAF50';
                                    video.play().catch(e => {
                                        console.log('Auto-play prevented, waiting for user interaction');
                                    });
                                });
                                
                                hls.on(Hls.Events.ERROR, function(event, data) {
                                    console.warn('Stream error:', data);
                                    if (data.fatal) {
                                        hls.destroy();
                                        statusDiv.textContent = 'HLS playback failed';
                                        statusDiv.style.color = '#ff4444';
                                                                               
                                        if (video.canPlayType('application/vnd.apple.mpegurl')) {
                                            video.src = videoUrl;
                                            video.load();
                                        }
                                    }
                                });
                            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                                statusDiv.textContent = 'Using Safari native HLS playback';
                                video.src = videoUrl;
                                video.load();
                            } else {
                                statusDiv.textContent = 'HLS not supported in this browser';
                                statusDiv.style.color = '#ff4444';
                            }
                        });
                    }).catch(error => {
                        statusDiv.textContent = 'Cannot test stream accessibility';
                        statusDiv.style.color = '#ff4444';
                        errorDiv.textContent = `Error: ''${error.message}`;
                        errorDiv.style.display = 'block';
                    });
                }
                
                async function testStreamAccessibility(url) {
                    try {
                        const response = await fetch(url, {
                            method: 'HEAD',
                            mode: 'cors',
                            cache: 'no-cache'
                        });
                        return response.ok;
                    } catch (headError) {
                        console.log('HEAD failed, trying GET with timeout:', headError);        
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 5000);       
                            const response = await fetch(url, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache',
                                signal: controller.signal,
                                headers: {
                                    'Range': 'bytes=0-100'
                                }
                            });
                            
                            clearTimeout(timeoutId);
                            return response.ok;
                        } catch (getError) {
                            console.log('GET also failed:', getError);
                            return false;
                        }
                    }
                }
                              
                function addErrorMessage(text) {
                    const chatContainer = document.getElementById('chat');
                    const typingIndicator = document.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        chatContainer.removeChild(typingIndicator);
                    }

                    const cleanedText = text
                        .split('\n')
                        .filter(line => !line.includes('Loading fuzzy index from:'))
                        .join('\n');

                    const errorBubble = document.createElement('div');
                    errorBubble.className = 'chat-bubble error-special-bubble';
    
                    const errorMatch = cleanedText.match(/ü¶Ü says ‚Æû fuck ‚ùå[^\n]*/);
                    const errorMessage = errorMatch ? errorMatch[0].replace('ü¶Ü says ‚Æû ', "") : 'Error!';
    
                    errorBubble.innerHTML = `
                        <div class="error-special-text">ü¶Üsays‚Æû''${errorMessage}</div>
                    `;
    
                    chatContainer.appendChild(errorBubble);
    
                    const matches = [];
                    const lines = cleanedText.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/(\d+)%:\s*'([^']+)'\s*->\s*(.*)/);
                        if (match) {
                            const [, percentage, pattern, command] = match;
                            matches.push({ percentage, pattern, command });
                        }
                    });
    
                    if (matches.length > 0) {
                        const suggestionBubble = document.createElement('div');
                        suggestionBubble.className = 'chat-bubble suggestion-header-bubble';
                        suggestionBubble.innerHTML = `
                            <div class="suggestion-header">Did you mean?</div>
                        `;
                        chatContainer.appendChild(suggestionBubble);
        
                        matches.forEach(match => {
                            const matchBubble = document.createElement('div');
                            matchBubble.className = 'chat-bubble suggestion-match-bubble';
                            matchBubble.innerHTML = `
                                <div class="match-percentage">''${match.percentage}% match</div>
                                <div class="match-pattern">''${match.pattern}</div>
                                <div class="match-command">‚Üí ''${match.command}</div>
                            `;

                            matchBubble.style.cursor = 'pointer';
                            matchBubble.addEventListener('click', () => {
                                document.getElementById('prompt').value = match.pattern.replace(/\{[^}]+\}/g, '...');
                                sendMessage();
                            });
                            chatContainer.appendChild(matchBubble);
                        });
                    }
    
                    chatContainer.scrollTop = chatContainer.scrollHeight;
    
                    const playFailAudio = () => {
                        const cacheBuster = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        const audio = new Audio('/tts/fail.wav?' + cacheBuster);
                        audio.volume = AUDIO_CONFIG.enabled ? AUDIO_CONFIG.volume : 0.8;
                        audio.play().catch(error => {
                            console.warn('Fail audio playback failed:', error);
                        });
                    };
                    setTimeout(playFailAudio, 300);
                }

                function formatCommandError(errorText) {
                  const lines = errorText.split('\n');
                  let html = "";
  
                  lines.forEach(line => {
                    if (line.includes('Input:')) {
                      html += `<div class="error-input"><strong>Your input:</strong> ''${line.replace('Input: ', "")}</div>`;
                    } else if (line.includes('%:')) {
                      const match = line.match(/(\d+)%:\s*'([^']+)'\s*->\s*(.*)/);
                      if (match) {
                        const [, percentage, pattern, command] = match;
                        html += `
                          <div class="close-match">
                            <span class="match-percentage">''${percentage}% match:</span>
                            <code class="match-pattern">''${pattern}</code>
                            <span class="match-command">‚Üí ''${command}</span>
                          </div>
                        `;
                      }
                    } else if (!line.includes('Loading fuzzy index')) {
                      html += line + '<br>';
                    }
                  });
  
                  return html;
                }
                
                function showTypingIndicator() {
                    const chatContainer = document.getElementById('chat');
                    const existingIndicator = document.querySelector('.typing-indicator');
                    if (existingIndicator) {
                        chatContainer.removeChild(existingIndicator);
                    }
                
                    const typingIndicator = document.createElement('div');
                    typingIndicator.className = 'typing-indicator';
                    typingIndicator.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
                    chatContainer.appendChild(typingIndicator);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
                
                async function sendCommandToAPI(command) {
                    if (!apiConnected) {
                        addErrorMessage("Not connected to API. Check if the API server is running.");
                        return false;
                    }
                
                    const uploadSuccess = await uploadFiles();
                    if (!uploadSuccess) {
                        return false;
                    }
                
                    showTypingIndicator(); 
                    try {
                        const lowerCommand = command.toLowerCase();                    
                        if (lowerCommand.startsWith('do ')) {
                            const naturalLanguageCommand = command.substring(3);
                            return await sendNaturalLanguageCommand(naturalLanguageCommand);
                        } else if (lowerCommand.includes('shopping') || lowerCommand.includes('shopping list')) {
                            return await fetchShoppingList();
                        } else if (lowerCommand.includes('reminder') || lowerCommand.includes('remind')) {
                            return await fetchReminders();
                        } else if (lowerCommand.includes('timer')) {
                            return await fetchTimers();
                        } else if (lowerCommand.includes('alarm')) {
                            return await fetchAlarms();
                        } else if (lowerCommand.includes('location') || lowerCommand.includes('where am i')) {
                            return await fetchLocation();
                        } else {
                            return await sendNaturalLanguageCommand(command);
                        }
                    } catch (error) {
                        console.error('API call failed:', error);
                        addErrorMessage("Failed to send command to API. Please check the connection.");
                        return false;
                    }
                }
                
                async function sendNaturalLanguageCommand(command) {
                  try {
                    const password = getAuthToken();
                    const response = await fetch(API_CONFIG.baseUrl + '/do?cmd=' + encodeURIComponent(command) + '&password=' + encodeURIComponent(password));
                    console.error(response); 
                    if (response.ok) {
                      let responseText = await response.text();
                      console.error(responseText); 
                      const rawOutput = extractOutputFromResponse(responseText);
                      console.error(rawOutput);
                      const cleanOutput = cleanAPIResponse(rawOutput);
                      console.error(cleanOutput);
                      const isError = cleanOutput.match(/(No matching command found|System rebuild failed)/);
      
                      if (isError) {   
                        addErrorMessage(cleanOutput);
                      } else {
                        addAIMessage(cleanOutput);
                      }
                      return true;
                    } else {
                      addErrorMessage('API Error: ' + response.status + ' - ' + response.statusText);
                      return false;
                    }
                  } catch (error) {
                    console.error('Yo DO command failed:', error);
                    addAIMessage("Command sent to API! (Check API logs for details)");
                    return true;
                  }
                }

                function sendMessage() {
                    const promptInput = document.getElementById('prompt');
                    const prompt = promptInput.value.trim();
                    const chatContainer = document.getElementById('chat');
                
                    if (prompt === "" && selectedFiles.length === 0) return;
                    if (prompt !== "") {
                        const userBubble = document.createElement('div');
                        userBubble.className = 'chat-bubble user-bubble';
                        userBubble.textContent = prompt;
                        chatContainer.appendChild(userBubble);
                        addToHistory(prompt);
                    }             
                    promptInput.value = "";
                    historyIndex = messageHistory.length;
                    chatContainer.scrollTop = chatContainer.scrollHeight;          
                    sendCommandToAPI(prompt);         
                    isFirstMessage = false;
                }
                
                function sendSuggestion(element) {
                    const text = element.textContent;
                    document.getElementById('prompt').value = text;
                    sendMessage();
                }
                
                function checkEnter(event) {
                    if (event.key === 'Enter') {
                        sendMessage();
                    } else if (event.key === 'ArrowUp') {
                        event.preventDefault();
                        navigateHistory('up');
                    } else if (event.key === 'ArrowDown') {
                        event.preventDefault();
                        navigateHistory('down');
                    }
                }
               
                setupFileUpload();
                checkAPIHealth();     
                document.getElementById('prompt').addEventListener('keydown', checkEnter);
                document.getElementById('send-button').addEventListener('click', sendMessage);        
                document.querySelectorAll('.suggestion-bubble').forEach(bubble => {
                    bubble.addEventListener('click', function() {
                        sendSuggestion(this);
                    });
                });            
                setTimeout(() => {
                    if (isFirstMessage) {
                        addAIMessage("Quack quack! I'm a ü¶Ü here to help! Qwack me a question yo!");
                    }
                }, 2000);

                setInterval(checkAPIHealth, 30000);
            <\/script>
          '';
        };
      };
    };

  };}
                </script>
            </div>
        </details>
        

                
        <p>
            I know that must have been a lot to take in, and I do appologize for the code structure, as I can barely see code organization is my biggest enemy.<br>
            If you had trouble following along in the code there, I suggest turning on the duck commentary and let the ducks guide you through it.<br><br>

        </p>

        <h2 class="section-title">Conclusion</h2>
        
        <p>
            <strong>So what did we end up with?</strong><br>
            Good question!<br><br>
            
            We now have a chat that you can communicate with using natural language, depending on your yo scripts, you can ask it questions, tell it to execute commands like control your lights, TV's, ask about your calendar events, check when your local train departures, check how your local sports team is doing etc etc.<br>
            As I am writing this I have <strong>60</strong> scripts available for use within the chat, so the possibilities are pretty much endless.<br><br>
            The chat response bubbles automatically renderes any possible tables or structured layouts as markdown for best possible look.<br>  
            It can even play media, like music or movies right in the chat response bubble. The chat will automatically recognize .m3u/m3u8 or video URL's from the yo scripts output and play them in the chat bubble. <br><br>
            
            When a chat response is recieved it will automatically play the /tts/tts.wav file if it has been modified within the last 30 seconds.<br><br>
            
            I also included a attachment button so I can send photo's or documents from my phone to store for backup on my server.<br><br>
            
            Clicking a chat bubble will pop it into full-screen mode.<br> 
            
            Here is one more demo video asking for a music playlist to be played on the TV.<br><br>

            <video width="400" controls>
                <source src="https://raw.githubusercontent.com/QuackHack-McBlindy/blog/main/img/playlist_cmd.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video><br><br>
                 
            <br>
           
            <h2 class="section-title">The Full Source</h2>
    
            <a href="https://github.com/QuackHack-McBlindy/dotfiles/blob/main/modules/myHouse.nix" class="source-link">
              View source code on GitHub
            </a><br>   



            <h2 class="section-title">Keep Reading</h2>
        

            <a href ="part1.html">Part 1. The module, the options and defining devices</a><br>
            <a href ="part2.html">Part 2. Configure your Mosquitto/Z2MQTT</a> <br>
            <a href ="part3.html">Part 3. Nix Configured Automations</a>  <br>              
            <a href ="part4.html">Part 4. Writing a Server Service - In Rust</a><br>          
            <a href ="part5.html">Part 5. Writing a Client - With Voice Commands</a>   <br>   
            <a href ="part6.html">Part 6. The Auto-Generated Dashboard</a><br>
            <a href ="part7.html">Part 7. Let's Build a ChatBot!</a> <span class="current-marker">‚óÄü¶Ühere u are</span><br>

            <br><br><br>
    
              

            <section id="comments">
              <h2>Comments on this blog post</h2>
              <script 
                src="https://utteranc.es/client.js"
                repo="QuackHack-McBlindy/blog"
                issue-term="pathname"
                theme="github-light"
                crossorigin="anonymous"
                async>
              </script>
            </section>
        </p>
    </div>



    </div>
    
    <footer>
        <p>All thoughts are my own and should not be considered advice of any kind.</p>
    </footer>

<script>
document.querySelectorAll('.code-block').forEach(block => {
    const duck = block.querySelector('.duck-version');
    const clean = block.querySelector('.clean-version');
    const duckSrc = block.querySelector('.duck-source');
    const cleanSrc = block.querySelector('.clean-source');

    if (duck && duckSrc) duck.textContent = duckSrc.textContent.trim();
    if (clean && cleanSrc) clean.textContent = cleanSrc.textContent.trim();
});
</script>
<script src="../js/script.js"></script>
</body>
</html>
